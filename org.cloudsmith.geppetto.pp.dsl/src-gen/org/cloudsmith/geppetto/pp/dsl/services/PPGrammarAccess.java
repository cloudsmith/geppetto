/*
* generated by Xtext
*/

package org.cloudsmith.geppetto.pp.dsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class PPGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class PuppetManifestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PuppetManifest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPuppetManifestAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsExpressionListParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		
		//PuppetManifest returns pp::PuppetManifest:
		//	{pp::PuppetManifest} statements+=ExpressionList*;
		public ParserRule getRule() { return rule; }

		//{pp::PuppetManifest} statements+=ExpressionList*
		public Group getGroup() { return cGroup; }

		//{pp::PuppetManifest}
		public Action getPuppetManifestAction_0() { return cPuppetManifestAction_0; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_1_0() { return cStatementsExpressionListParserRuleCall_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cRelationshipExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// -- EXPRESSION
		//// (Refers to the expression with the lowest precedence)
		//// Should be used by expressions that allow a single Expression
		//Expression returns pp::Expression:
		//	RelationshipExpression;
		public ParserRule getRule() { return rule; }

		//RelationshipExpression
		public RuleCall getRelationshipExpressionParserRuleCall() { return cRelationshipExpressionParserRuleCall; }
	}

	public class ExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationshipExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExprListExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionsRelationshipExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionsAssignment_1_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cCommaKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cExpressionsRelationshipExpressionParserRuleCall_1_3_1_0 = (RuleCall)cExpressionsAssignment_1_3_1.eContents().get(0);
		
		//// --EXPRESSION LIST
		//// Should be used by expressions that allow a sequence of expressions (as such
		//// a sequence can include non-parenthesized function calls (which are detected after
		//// parsing)
		//ExpressionList returns pp::Expression:
		//	RelationshipExpression ({pp::ExprList.expressions+=current} "," expressions+=RelationshipExpression (","
		//	expressions+=RelationshipExpression)*)?;
		public ParserRule getRule() { return rule; }

		//RelationshipExpression ({pp::ExprList.expressions+=current} "," expressions+=RelationshipExpression (","
		//expressions+=RelationshipExpression)*)?
		public Group getGroup() { return cGroup; }

		//RelationshipExpression
		public RuleCall getRelationshipExpressionParserRuleCall_0() { return cRelationshipExpressionParserRuleCall_0; }

		//({pp::ExprList.expressions+=current} "," expressions+=RelationshipExpression (","
		//expressions+=RelationshipExpression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::ExprList.expressions+=current}
		public Action getExprListExpressionsAction_1_0() { return cExprListExpressionsAction_1_0; }

		//","
		public Keyword getCommaKeyword_1_1() { return cCommaKeyword_1_1; }

		//expressions+=RelationshipExpression
		public Assignment getExpressionsAssignment_1_2() { return cExpressionsAssignment_1_2; }

		//RelationshipExpression
		public RuleCall getExpressionsRelationshipExpressionParserRuleCall_1_2_0() { return cExpressionsRelationshipExpressionParserRuleCall_1_2_0; }

		//("," expressions+=RelationshipExpression)*
		public Group getGroup_1_3() { return cGroup_1_3; }

		//","
		public Keyword getCommaKeyword_1_3_0() { return cCommaKeyword_1_3_0; }

		//expressions+=RelationshipExpression
		public Assignment getExpressionsAssignment_1_3_1() { return cExpressionsAssignment_1_3_1; }

		//RelationshipExpression
		public RuleCall getExpressionsRelationshipExpressionParserRuleCall_1_3_1_0() { return cExpressionsRelationshipExpressionParserRuleCall_1_3_1_0; }
	}

	public class EdgeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EdgeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTildeGreaterThanSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignTildeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//// LOWEST PRECEDENCE
		////  left  relationship
		////  left  assignment
		////  left  OR
		////  left  AND
		////  left  Relational: GREATEREQUAL GREATERTHAN LESSTHAN LESSEQUAL
		////  left  Equality: NOTEQUAL ISEQUAL
		////  left  Shift: LSHIFT RSHIFT
		////  left  Additive: '-' PLUS
		////  left  Multiplicative: TIMES DIV
		////  left  Matching: IN MATCH NOMATCH
		////  nonassoc UMINUS
		////  right NOT
		////  'primary'
		//// HIGHEST
		//// Relationship
		//// Note that RelationshipExpression has lowest precedence since it has an operator
		//// '<-' that otherwise clashes with LT UnaryMinus
		////
		//// VALIDATION checks that left and right are one of: 
		//// - ResourceExpression (but not a ResourceOverride, or virtual resource)
		//// - ResourceReference
		//// - CollectExpression
		//EdgeOperator:
		//	"->" | "<-" | "~>" | "<~";
		public ParserRule getRule() { return rule; }

		//"->" | "<-" | "~>" | "<~"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_0() { return cHyphenMinusGreaterThanSignKeyword_0; }

		//"<-"
		public Keyword getLessThanSignHyphenMinusKeyword_1() { return cLessThanSignHyphenMinusKeyword_1; }

		//"~>"
		public Keyword getTildeGreaterThanSignKeyword_2() { return cTildeGreaterThanSignKeyword_2; }

		//"<~"
		public Keyword getLessThanSignTildeKeyword_3() { return cLessThanSignTildeKeyword_3; }
	}

	public class RelationshipExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationshipExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cResourceExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationshipExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameEdgeOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprResourceExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//RelationshipExpression returns pp::Expression:
		//	ResourceExpression ({pp::RelationshipExpression.leftExpr=current} opName=EdgeOperator rightExpr=ResourceExpression)*;
		public ParserRule getRule() { return rule; }

		//ResourceExpression ({pp::RelationshipExpression.leftExpr=current} opName=EdgeOperator rightExpr=ResourceExpression)*
		public Group getGroup() { return cGroup; }

		//ResourceExpression
		public RuleCall getResourceExpressionParserRuleCall_0() { return cResourceExpressionParserRuleCall_0; }

		//({pp::RelationshipExpression.leftExpr=current} opName=EdgeOperator rightExpr=ResourceExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::RelationshipExpression.leftExpr=current}
		public Action getRelationshipExpressionLeftExprAction_1_0() { return cRelationshipExpressionLeftExprAction_1_0; }

		//opName=EdgeOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//EdgeOperator
		public RuleCall getOpNameEdgeOperatorParserRuleCall_1_1_0() { return cOpNameEdgeOperatorParserRuleCall_1_1_0; }

		//rightExpr=ResourceExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//ResourceExpression
		public RuleCall getRightExprResourceExpressionParserRuleCall_1_2_0() { return cRightExprResourceExpressionParserRuleCall_1_2_0; }
	}

	public class ResourceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResourceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAssignmentExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cResourceExpressionResourceExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cResourceDataAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cResourceDataResourceBodyParserRuleCall_1_2_0_0 = (RuleCall)cResourceDataAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cResourceDataAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cResourceDataResourceBodyParserRuleCall_1_2_1_1_0 = (RuleCall)cResourceDataAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//// -- ResourceExpression 
		//// handles:
		//// - resource definition 'name {'
		//// - defaults for resource definitions  'Name {'
		//// - resource overrides 'expr [exprlist] {'
		//// - virtual and exported resources @name {, and @@name {
		//// The parser makes no distinction between these and allows nested expresions compatible with all three
		//// VALIDATION checks:
		//// - if resourceClass != CLASS_REF, then ResourceBodies must have a name
		//// - if resourceClass == CLASS_REF or AtExpression, 
		////		then only one ResourceBody is allowed, and ResourceBody can not have a name
		//// - if resourceExpr = AtExpression the ResourceBody's attribute list may contain additions, otherwise not			
		////
		//ResourceExpression returns pp::Expression:
		//	AssignmentExpression ({pp::ResourceExpression.resourceExpr=current} "{" (resourceData+=ResourceBody (";"
		//	resourceData+=ResourceBody)* ";"?)? "}")?;
		public ParserRule getRule() { return rule; }

		//AssignmentExpression ({pp::ResourceExpression.resourceExpr=current} "{" (resourceData+=ResourceBody (";"
		//resourceData+=ResourceBody)* ";"?)? "}")?
		public Group getGroup() { return cGroup; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_0() { return cAssignmentExpressionParserRuleCall_0; }

		//({pp::ResourceExpression.resourceExpr=current} "{" (resourceData+=ResourceBody (";" resourceData+=ResourceBody)* ";"?)?
		//"}")?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::ResourceExpression.resourceExpr=current}
		public Action getResourceExpressionResourceExprAction_1_0() { return cResourceExpressionResourceExprAction_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }

		//(resourceData+=ResourceBody (";" resourceData+=ResourceBody)* ";"?)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//resourceData+=ResourceBody
		public Assignment getResourceDataAssignment_1_2_0() { return cResourceDataAssignment_1_2_0; }

		//ResourceBody
		public RuleCall getResourceDataResourceBodyParserRuleCall_1_2_0_0() { return cResourceDataResourceBodyParserRuleCall_1_2_0_0; }

		//(";" resourceData+=ResourceBody)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//";"
		public Keyword getSemicolonKeyword_1_2_1_0() { return cSemicolonKeyword_1_2_1_0; }

		//resourceData+=ResourceBody
		public Assignment getResourceDataAssignment_1_2_1_1() { return cResourceDataAssignment_1_2_1_1; }

		//ResourceBody
		public RuleCall getResourceDataResourceBodyParserRuleCall_1_2_1_1_0() { return cResourceDataResourceBodyParserRuleCall_1_2_1_1_0; }

		//";"?
		public Keyword getSemicolonKeyword_1_2_2() { return cSemicolonKeyword_1_2_2; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }
	}

	public class ResourceBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResourceBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cNameExprAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cNameExprExpressionParserRuleCall_0_0_0 = (RuleCall)cNameExprAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cAttributesAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cAttributesAttributeOperationsParserRuleCall_0_2_0 = (RuleCall)cAttributesAssignment_0_2.eContents().get(0);
		private final Assignment cAttributesAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cAttributesAttributeOperationsParserRuleCall_1_0 = (RuleCall)cAttributesAssignment_1.eContents().get(0);
		
		//// Note: allows all AttributeOperation subtypes but this depends on the parent's type
		//// VALIDATION checks allowed types	
		//ResourceBody returns pp::ResourceBody:
		//	nameExpr=Expression ":" attributes=AttributeOperations? | attributes=AttributeOperations;
		public ParserRule getRule() { return rule; }

		//nameExpr=Expression ":" attributes=AttributeOperations? | attributes=AttributeOperations
		public Alternatives getAlternatives() { return cAlternatives; }

		//nameExpr=Expression ":" attributes=AttributeOperations?
		public Group getGroup_0() { return cGroup_0; }

		//nameExpr=Expression
		public Assignment getNameExprAssignment_0_0() { return cNameExprAssignment_0_0; }

		//Expression
		public RuleCall getNameExprExpressionParserRuleCall_0_0_0() { return cNameExprExpressionParserRuleCall_0_0_0; }

		//":"
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//attributes=AttributeOperations?
		public Assignment getAttributesAssignment_0_2() { return cAttributesAssignment_0_2; }

		//AttributeOperations
		public RuleCall getAttributesAttributeOperationsParserRuleCall_0_2_0() { return cAttributesAttributeOperationsParserRuleCall_0_2_0; }

		//attributes=AttributeOperations
		public Assignment getAttributesAssignment_1() { return cAttributesAssignment_1; }

		//AttributeOperations
		public RuleCall getAttributesAttributeOperationsParserRuleCall_1_0() { return cAttributesAttributeOperationsParserRuleCall_1_0; }
	}

	public class AttributeOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyUnionNameOrReferenceParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Alternatives cOpAlternatives_1_0_0 = (Alternatives)cOpAssignment_1_0.eContents().get(0);
		private final Keyword cOpEqualsSignGreaterThanSignKeyword_1_0_0_0 = (Keyword)cOpAlternatives_1_0_0.eContents().get(0);
		private final Keyword cOpPlusSignGreaterThanSignKeyword_1_0_0_1 = (Keyword)cOpAlternatives_1_0_0.eContents().get(1);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		////// VALIDATION: checks that key is a NAME
		////AttributeDefinition returns pp::AttributeDefinition
		////	: unionNameOrReference ({pp::AttributeDefinition.key = current} '=>' value = Expression) 
		//////	:  key = unionNameOrReference  '=>'  value = Expression 
		////	;
		////// VALIDATION: checks that key is a NAME
		////AttributeAddition returns pp::AttributeAddition
		////	:  key = unionNameOrReference  '+>'  value = Expression
		////	;
		//// VALIDATION: key is a NAME, op is supported and Expression is not null
		//AttributeOperation returns pp::AttributeOperation:
		//	=> key=unionNameOrReference (op=("=>" | "+>") value=Expression)?;
		public ParserRule getRule() { return rule; }

		//=> key=unionNameOrReference (op=("=>" | "+>") value=Expression)?
		public Group getGroup() { return cGroup; }

		//=> key=unionNameOrReference
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//unionNameOrReference
		public RuleCall getKeyUnionNameOrReferenceParserRuleCall_0_0() { return cKeyUnionNameOrReferenceParserRuleCall_0_0; }

		//(op=("=>" | "+>") value=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//op=("=>" | "+>")
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }

		//"=>" | "+>"
		public Alternatives getOpAlternatives_1_0_0() { return cOpAlternatives_1_0_0; }

		//"=>"
		public Keyword getOpEqualsSignGreaterThanSignKeyword_1_0_0_0() { return cOpEqualsSignGreaterThanSignKeyword_1_0_0_0; }

		//"+>"
		public Keyword getOpPlusSignGreaterThanSignKeyword_1_0_0_1() { return cOpPlusSignGreaterThanSignKeyword_1_0_0_1; }

		//value=Expression
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_1_0() { return cValueExpressionParserRuleCall_1_1_0; }
	}

	public class AttributeOperationsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AttributeOperations");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAttributesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAttributesAttributeOperationParserRuleCall_0_0 = (RuleCall)cAttributesAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cAttributesAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cAttributesAttributeOperationParserRuleCall_1_0_1_0 = (RuleCall)cAttributesAssignment_1_0_1.eContents().get(0);
		private final Assignment cAttributesAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cAttributesAttributeOperationParserRuleCall_1_1_0 = (RuleCall)cAttributesAssignment_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////AttributeOperation returns pp::AttributeOperation
		////	: AttributeDefinition
		////	| AttributeAddition
		////	;
		//// VALIDATION: checks that there are ',' between operations
		//// NOTE: if ','	is mandatory in grammar, backtracking will think statement is a different (faulty)
		//// statement.
		//AttributeOperations returns pp::AttributeOperations:
		//	attributes+=AttributeOperation ("," attributes+=AttributeOperation | attributes+=AttributeOperation)* ","?;
		public ParserRule getRule() { return rule; }

		//attributes+=AttributeOperation ("," attributes+=AttributeOperation | attributes+=AttributeOperation)* ","?
		public Group getGroup() { return cGroup; }

		//attributes+=AttributeOperation
		public Assignment getAttributesAssignment_0() { return cAttributesAssignment_0; }

		//AttributeOperation
		public RuleCall getAttributesAttributeOperationParserRuleCall_0_0() { return cAttributesAttributeOperationParserRuleCall_0_0; }

		//("," attributes+=AttributeOperation | attributes+=AttributeOperation)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"," attributes+=AttributeOperation
		public Group getGroup_1_0() { return cGroup_1_0; }

		//","
		public Keyword getCommaKeyword_1_0_0() { return cCommaKeyword_1_0_0; }

		//attributes+=AttributeOperation
		public Assignment getAttributesAssignment_1_0_1() { return cAttributesAssignment_1_0_1; }

		//AttributeOperation
		public RuleCall getAttributesAttributeOperationParserRuleCall_1_0_1_0() { return cAttributesAttributeOperationParserRuleCall_1_0_1_0; }

		//attributes+=AttributeOperation
		public Assignment getAttributesAssignment_1_1() { return cAttributesAssignment_1_1; }

		//AttributeOperation
		public RuleCall getAttributesAttributeOperationParserRuleCall_1_1_0() { return cAttributesAttributeOperationParserRuleCall_1_1_0; }

		//","?
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
	}

	public class EndCommaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "endComma");
		private final Keyword cCommaKeyword = (Keyword)rule.eContents().get(1);
		
		//// NOTE: This construct is required due to an Xtext bug, it would be preferred to state (',' )? directly
		//// in rules using endComma as this makes formatting work ok. The construct below will hide the  and
		//// formatting needs to be aware of the  in an endComma.
		//endComma:
		//	",";
		public ParserRule getRule() { return rule; }

		//","
		public Keyword getCommaKeyword() { return cCommaKeyword; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAppendExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAppendExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//// VALIDATION checks leftExpr must be '@' or Variable
		//AssignmentExpression returns pp::Expression:
		//	AppendExpression ({pp::AssignmentExpression.leftExpr=current} "=" rightExpr=AppendExpression)?;
		public ParserRule getRule() { return rule; }

		//AppendExpression ({pp::AssignmentExpression.leftExpr=current} "=" rightExpr=AppendExpression)?
		public Group getGroup() { return cGroup; }

		//AppendExpression
		public RuleCall getAppendExpressionParserRuleCall_0() { return cAppendExpressionParserRuleCall_0; }

		//({pp::AssignmentExpression.leftExpr=current} "=" rightExpr=AppendExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::AssignmentExpression.leftExpr=current}
		public Action getAssignmentExpressionLeftExprAction_1_0() { return cAssignmentExpressionLeftExprAction_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }

		//rightExpr=AppendExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AppendExpression
		public RuleCall getRightExprAppendExpressionParserRuleCall_1_2_0() { return cRightExprAppendExpressionParserRuleCall_1_2_0; }
	}

	public class AppendExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AppendExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAppendExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//// VALIDATION checks leftExpr must be Variable (does not seem to allow append to at - e.g. a[1] +=)
		//AppendExpression returns pp::Expression:
		//	OrExpression ({pp::AppendExpression.leftExpr=current} "+=" rightExpr=OrExpression)?;
		public ParserRule getRule() { return rule; }

		//OrExpression ({pp::AppendExpression.leftExpr=current} "+=" rightExpr=OrExpression)?
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({pp::AppendExpression.leftExpr=current} "+=" rightExpr=OrExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::AppendExpression.leftExpr=current}
		public Action getAppendExpressionLeftExprAction_1_0() { return cAppendExpressionLeftExprAction_1_0; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_1_1() { return cPlusSignEqualsSignKeyword_1_1; }

		//rightExpr=OrExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//OrExpression
		public RuleCall getRightExprOrExpressionParserRuleCall_1_2_0() { return cRightExprOrExpressionParserRuleCall_1_2_0; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//OrExpression returns pp::Expression:
		//	AndExpression ({pp::OrExpression.leftExpr=current} "or" rightExpr=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({pp::OrExpression.leftExpr=current} "or" rightExpr=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({pp::OrExpression.leftExpr=current} "or" rightExpr=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::OrExpression.leftExpr=current}
		public Action getOrExpressionLeftExprAction_1_0() { return cOrExpressionLeftExprAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//rightExpr=AndExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AndExpression
		public RuleCall getRightExprAndExpressionParserRuleCall_1_2_0() { return cRightExprAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprRelationalExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AndExpression returns pp::Expression:
		//	RelationalExpression ({pp::AndExpression.leftExpr=current} "and" rightExpr=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//RelationalExpression ({pp::AndExpression.leftExpr=current} "and" rightExpr=RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({pp::AndExpression.leftExpr=current} "and" rightExpr=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::AndExpression.leftExpr=current}
		public Action getAndExpressionLeftExprAction_1_0() { return cAndExpressionLeftExprAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//rightExpr=RelationalExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//RelationalExpression
		public RuleCall getRightExprRelationalExpressionParserRuleCall_1_2_0() { return cRightExprRelationalExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//RelationalOperator:
		//	">=" | "<=" | ">" | "<";
		public ParserRule getRule() { return rule; }

		//">=" | "<=" | ">" | "<"
		public Alternatives getAlternatives() { return cAlternatives; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_0() { return cGreaterThanSignEqualsSignKeyword_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }

		//"<"
		public Keyword getLessThanSignKeyword_3() { return cLessThanSignKeyword_3; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameRelationalOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprEqualityExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//RelationalExpression returns pp::Expression:
		//	EqualityExpression ({pp::RelationalExpression.leftExpr=current} opName=RelationalOperator
		//	rightExpr=EqualityExpression)*;
		public ParserRule getRule() { return rule; }

		//EqualityExpression ({pp::RelationalExpression.leftExpr=current} opName=RelationalOperator rightExpr=EqualityExpression)*
		public Group getGroup() { return cGroup; }

		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }

		//({pp::RelationalExpression.leftExpr=current} opName=RelationalOperator rightExpr=EqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::RelationalExpression.leftExpr=current}
		public Action getRelationalExpressionLeftExprAction_1_0() { return cRelationalExpressionLeftExprAction_1_0; }

		//opName=RelationalOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//RelationalOperator
		public RuleCall getOpNameRelationalOperatorParserRuleCall_1_1_0() { return cOpNameRelationalOperatorParserRuleCall_1_1_0; }

		//rightExpr=EqualityExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//EqualityExpression
		public RuleCall getRightExprEqualityExpressionParserRuleCall_1_2_0() { return cRightExprEqualityExpressionParserRuleCall_1_2_0; }
	}

	public class EqualityOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EqualityOperator:
		//	"==" | "!=";
		public ParserRule getRule() { return rule; }

		//"==" | "!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_0() { return cEqualsSignEqualsSignKeyword_0; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1() { return cExclamationMarkEqualsSignKeyword_1; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cShiftExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameEqualityOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprShiftExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//EqualityExpression returns pp::Expression:
		//	ShiftExpression ({pp::EqualityExpression.leftExpr=current} opName=EqualityOperator rightExpr=ShiftExpression)*;
		public ParserRule getRule() { return rule; }

		//ShiftExpression ({pp::EqualityExpression.leftExpr=current} opName=EqualityOperator rightExpr=ShiftExpression)*
		public Group getGroup() { return cGroup; }

		//ShiftExpression
		public RuleCall getShiftExpressionParserRuleCall_0() { return cShiftExpressionParserRuleCall_0; }

		//({pp::EqualityExpression.leftExpr=current} opName=EqualityOperator rightExpr=ShiftExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::EqualityExpression.leftExpr=current}
		public Action getEqualityExpressionLeftExprAction_1_0() { return cEqualityExpressionLeftExprAction_1_0; }

		//opName=EqualityOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//EqualityOperator
		public RuleCall getOpNameEqualityOperatorParserRuleCall_1_1_0() { return cOpNameEqualityOperatorParserRuleCall_1_1_0; }

		//rightExpr=ShiftExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//ShiftExpression
		public RuleCall getRightExprShiftExpressionParserRuleCall_1_2_0() { return cRightExprShiftExpressionParserRuleCall_1_2_0; }
	}

	public class ShiftOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLessThanSignLessThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//ShiftOperator:
		//	"<<" | ">>";
		public ParserRule getRule() { return rule; }

		//"<<" | ">>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"<<"
		public Keyword getLessThanSignLessThanSignKeyword_0() { return cLessThanSignLessThanSignKeyword_0; }

		//">>"
		public Keyword getGreaterThanSignGreaterThanSignKeyword_1() { return cGreaterThanSignGreaterThanSignKeyword_1; }
	}

	public class ShiftExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cShiftExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameShiftOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprAdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//ShiftExpression returns pp::Expression:
		//	AdditiveExpression ({pp::ShiftExpression.leftExpr=current} opName=ShiftOperator rightExpr=AdditiveExpression)*;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ({pp::ShiftExpression.leftExpr=current} opName=ShiftOperator rightExpr=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({pp::ShiftExpression.leftExpr=current} opName=ShiftOperator rightExpr=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::ShiftExpression.leftExpr=current}
		public Action getShiftExpressionLeftExprAction_1_0() { return cShiftExpressionLeftExprAction_1_0; }

		//opName=ShiftOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//ShiftOperator
		public RuleCall getOpNameShiftOperatorParserRuleCall_1_1_0() { return cOpNameShiftOperatorParserRuleCall_1_1_0; }

		//rightExpr=AdditiveExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//AdditiveExpression
		public RuleCall getRightExprAdditiveExpressionParserRuleCall_1_2_0() { return cRightExprAdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//AdditiveOperator:
		//	"+" | "-";
		public ParserRule getRule() { return rule; }

		//"+" | "-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+"
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditiveExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameAdditiveOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprMultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns pp::Expression:
		//	MultiplicativeExpression ({pp::AdditiveExpression.leftExpr=current} opName=AdditiveOperator
		//	rightExpr=MultiplicativeExpression)*;
		public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({pp::AdditiveExpression.leftExpr=current} opName=AdditiveOperator
		//rightExpr=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({pp::AdditiveExpression.leftExpr=current} opName=AdditiveOperator rightExpr=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::AdditiveExpression.leftExpr=current}
		public Action getAdditiveExpressionLeftExprAction_1_0() { return cAdditiveExpressionLeftExprAction_1_0; }

		//opName=AdditiveOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//AdditiveOperator
		public RuleCall getOpNameAdditiveOperatorParserRuleCall_1_1_0() { return cOpNameAdditiveOperatorParserRuleCall_1_1_0; }

		//rightExpr=MultiplicativeExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getRightExprMultiplicativeExpressionParserRuleCall_1_2_0() { return cRightExprMultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//MultiplicativeOperator:
		//	"*" | "/";
		public ParserRule getRule() { return rule; }

		//"*" | "/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMatchingExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicativeExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameMultiplicativeOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprMatchingExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//MultiplicativeExpression returns pp::Expression:
		//	MatchingExpression ({pp::MultiplicativeExpression.leftExpr=current} opName=MultiplicativeOperator
		//	rightExpr=MatchingExpression)*;
		public ParserRule getRule() { return rule; }

		//MatchingExpression ({pp::MultiplicativeExpression.leftExpr=current} opName=MultiplicativeOperator
		//rightExpr=MatchingExpression)*
		public Group getGroup() { return cGroup; }

		//MatchingExpression
		public RuleCall getMatchingExpressionParserRuleCall_0() { return cMatchingExpressionParserRuleCall_0; }

		//({pp::MultiplicativeExpression.leftExpr=current} opName=MultiplicativeOperator rightExpr=MatchingExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::MultiplicativeExpression.leftExpr=current}
		public Action getMultiplicativeExpressionLeftExprAction_1_0() { return cMultiplicativeExpressionLeftExprAction_1_0; }

		//opName=MultiplicativeOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//MultiplicativeOperator
		public RuleCall getOpNameMultiplicativeOperatorParserRuleCall_1_1_0() { return cOpNameMultiplicativeOperatorParserRuleCall_1_1_0; }

		//rightExpr=MatchingExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//MatchingExpression
		public RuleCall getRightExprMatchingExpressionParserRuleCall_1_2_0() { return cRightExprMatchingExpressionParserRuleCall_1_2_0; }
	}

	public class MatchingOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MatchingOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignTildeKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkTildeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// VALIDATION checks regex rhs
		//MatchingOperator:
		//	"=~" | "!~";
		public ParserRule getRule() { return rule; }

		//"=~" | "!~"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"=~"
		public Keyword getEqualsSignTildeKeyword_0() { return cEqualsSignTildeKeyword_0; }

		//"!~"
		public Keyword getExclamationMarkTildeKeyword_1() { return cExclamationMarkTildeKeyword_1; }
	}

	public class MatchingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MatchingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMatchingExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpNameMatchingOperatorParserRuleCall_1_1_0 = (RuleCall)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprLiteralRegexParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//MatchingExpression returns pp::Expression:
		//	InExpression ({pp::MatchingExpression.leftExpr=current} opName=MatchingOperator rightExpr=LiteralRegex)*;
		public ParserRule getRule() { return rule; }

		//InExpression ({pp::MatchingExpression.leftExpr=current} opName=MatchingOperator rightExpr=LiteralRegex)*
		public Group getGroup() { return cGroup; }

		//InExpression
		public RuleCall getInExpressionParserRuleCall_0() { return cInExpressionParserRuleCall_0; }

		//({pp::MatchingExpression.leftExpr=current} opName=MatchingOperator rightExpr=LiteralRegex)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::MatchingExpression.leftExpr=current}
		public Action getMatchingExpressionLeftExprAction_1_0() { return cMatchingExpressionLeftExprAction_1_0; }

		//opName=MatchingOperator
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//MatchingOperator
		public RuleCall getOpNameMatchingOperatorParserRuleCall_1_1_0() { return cOpNameMatchingOperatorParserRuleCall_1_1_0; }

		//rightExpr=LiteralRegex
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//LiteralRegex
		public RuleCall getRightExprLiteralRegexParserRuleCall_1_2_0() { return cRightExprLiteralRegexParserRuleCall_1_2_0; }
	}

	public class InExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOrHigherExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cInExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpNameInKeyword_1_1_0 = (Keyword)cOpNameAssignment_1_1.eContents().get(0);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprUnaryOrHigherExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//InExpression returns pp::Expression:
		//	UnaryOrHigherExpression ({pp::InExpression.leftExpr=current} opName="in" rightExpr=UnaryOrHigherExpression)*;
		public ParserRule getRule() { return rule; }

		//UnaryOrHigherExpression ({pp::InExpression.leftExpr=current} opName="in" rightExpr=UnaryOrHigherExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryOrHigherExpression
		public RuleCall getUnaryOrHigherExpressionParserRuleCall_0() { return cUnaryOrHigherExpressionParserRuleCall_0; }

		//({pp::InExpression.leftExpr=current} opName="in" rightExpr=UnaryOrHigherExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::InExpression.leftExpr=current}
		public Action getInExpressionLeftExprAction_1_0() { return cInExpressionLeftExprAction_1_0; }

		//opName="in"
		public Assignment getOpNameAssignment_1_1() { return cOpNameAssignment_1_1; }

		//"in"
		public Keyword getOpNameInKeyword_1_1_0() { return cOpNameInKeyword_1_1_0; }

		//rightExpr=UnaryOrHigherExpression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//UnaryOrHigherExpression
		public RuleCall getRightExprUnaryOrHigherExpressionParserRuleCall_1_2_0() { return cRightExprUnaryOrHigherExpressionParserRuleCall_1_2_0; }
	}

	public class UnaryOrHigherExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOrHigherExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryMinusExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNotExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnaryOrHigherExpression returns pp::Expression:
		//	UnaryMinusExpression | NotExpression | CollectExpression;
		public ParserRule getRule() { return rule; }

		//UnaryMinusExpression | NotExpression | CollectExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//UnaryMinusExpression
		public RuleCall getUnaryMinusExpressionParserRuleCall_0() { return cUnaryMinusExpressionParserRuleCall_0; }

		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_1() { return cNotExpressionParserRuleCall_1; }

		//CollectExpression
		public RuleCall getCollectExpressionParserRuleCall_2() { return cCollectExpressionParserRuleCall_2; }
	}

	public class UnaryMinusExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryMinusExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprCollectExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//UnaryMinusExpression returns pp::UnaryMinusExpression:
		//	"-" expr=CollectExpression;
		public ParserRule getRule() { return rule; }

		//"-" expr=CollectExpression
		public Group getGroup() { return cGroup; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//expr=CollectExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//CollectExpression
		public RuleCall getExprCollectExpressionParserRuleCall_1_0() { return cExprCollectExpressionParserRuleCall_1_0; }
	}

	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprCollectExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//NotExpression returns pp::UnaryNotExpression:
		//	"!" expr=CollectExpression;
		public ParserRule getRule() { return rule; }

		//"!" expr=CollectExpression
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//expr=CollectExpression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//CollectExpression
		public RuleCall getExprCollectExpressionParserRuleCall_1_0() { return cExprCollectExpressionParserRuleCall_1_0; }
	}

	public class CollectExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSelectorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCollectExpressionClassReferenceAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cQueryAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cQueryCollectQueryParserRuleCall_1_1_0 = (RuleCall)cQueryAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cAttributesAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cAttributesAttributeOperationsParserRuleCall_1_2_1_0 = (RuleCall)cAttributesAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		
		//// VALIDATION checks that CollectExpression classReference is a ClassReference, and that query expressions
		//// conform to a limit set of supported expressions.
		//CollectExpression returns pp::Expression:
		//	SelectorExpression ({pp::CollectExpression.classReference=current} query=CollectQuery ("{"
		//	attributes=AttributeOperations? "}")?)?;
		public ParserRule getRule() { return rule; }

		//SelectorExpression ({pp::CollectExpression.classReference=current} query=CollectQuery ("{"
		//attributes=AttributeOperations? "}")?)?
		public Group getGroup() { return cGroup; }

		//SelectorExpression
		public RuleCall getSelectorExpressionParserRuleCall_0() { return cSelectorExpressionParserRuleCall_0; }

		//({pp::CollectExpression.classReference=current} query=CollectQuery ("{" attributes=AttributeOperations? "}")?)?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::CollectExpression.classReference=current}
		public Action getCollectExpressionClassReferenceAction_1_0() { return cCollectExpressionClassReferenceAction_1_0; }

		//query=CollectQuery
		public Assignment getQueryAssignment_1_1() { return cQueryAssignment_1_1; }

		//CollectQuery
		public RuleCall getQueryCollectQueryParserRuleCall_1_1_0() { return cQueryCollectQueryParserRuleCall_1_1_0; }

		//("{" attributes=AttributeOperations? "}")?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_2_0() { return cLeftCurlyBracketKeyword_1_2_0; }

		//attributes=AttributeOperations?
		public Assignment getAttributesAssignment_1_2_1() { return cAttributesAssignment_1_2_1; }

		//AttributeOperations
		public RuleCall getAttributesAttributeOperationsParserRuleCall_1_2_1_0() { return cAttributesAttributeOperationsParserRuleCall_1_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_2_2() { return cRightCurlyBracketKeyword_1_2_2; }
	}

	public class CollectQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectQuery");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVirtualCollectQueryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExportedCollectQueryParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// VALIDATION ensures that query only contains:
		////  - ('and' | 'or' | VariableExpression | LiteralName | '==' | '!=' | ParentesisesExpression )	
		//CollectQuery returns pp::ICollectQuery:
		//	VirtualCollectQuery | ExportedCollectQuery;
		public ParserRule getRule() { return rule; }

		//VirtualCollectQuery | ExportedCollectQuery
		public Alternatives getAlternatives() { return cAlternatives; }

		//VirtualCollectQuery
		public RuleCall getVirtualCollectQueryParserRuleCall_0() { return cVirtualCollectQueryParserRuleCall_0; }

		//ExportedCollectQuery
		public RuleCall getExportedCollectQueryParserRuleCall_1() { return cExportedCollectQueryParserRuleCall_1; }
	}

	public class VirtualCollectQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VirtualCollectQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVirtualCollectQueryAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignVerticalLineKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//VirtualCollectQuery returns pp::ICollectQuery:
		//	{pp::VirtualCollectQuery} "<|" expr=Expression? "|>";
		public ParserRule getRule() { return rule; }

		//{pp::VirtualCollectQuery} "<|" expr=Expression? "|>"
		public Group getGroup() { return cGroup; }

		//{pp::VirtualCollectQuery}
		public Action getVirtualCollectQueryAction_0() { return cVirtualCollectQueryAction_0; }

		//"<|"
		public Keyword getLessThanSignVerticalLineKeyword_1() { return cLessThanSignVerticalLineKeyword_1; }

		//expr=Expression?
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }

		//"|>"
		public Keyword getVerticalLineGreaterThanSignKeyword_3() { return cVerticalLineGreaterThanSignKeyword_3; }
	}

	public class ExportedCollectQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExportedCollectQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExportedCollectQueryAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignLessThanSignVerticalLineKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineGreaterThanSignGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ExportedCollectQuery returns pp::ICollectQuery:
		//	{pp::ExportedCollectQuery} "<<|" expr=Expression? "|>>";
		public ParserRule getRule() { return rule; }

		//{pp::ExportedCollectQuery} "<<|" expr=Expression? "|>>"
		public Group getGroup() { return cGroup; }

		//{pp::ExportedCollectQuery}
		public Action getExportedCollectQueryAction_0() { return cExportedCollectQueryAction_0; }

		//"<<|"
		public Keyword getLessThanSignLessThanSignVerticalLineKeyword_1() { return cLessThanSignLessThanSignVerticalLineKeyword_1; }

		//expr=Expression?
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }

		//"|>>"
		public Keyword getVerticalLineGreaterThanSignGreaterThanSignKeyword_3() { return cVerticalLineGreaterThanSignGreaterThanSignKeyword_3; }
	}

	public class SelectorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSelectorExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Group cGroup_1_2_0 = (Group)cAlternatives_1_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_2_0_0 = (Keyword)cGroup_1_2_0.eContents().get(0);
		private final Assignment cParametersAssignment_1_2_0_1 = (Assignment)cGroup_1_2_0.eContents().get(1);
		private final RuleCall cParametersSelectorEntryParserRuleCall_1_2_0_1_0 = (RuleCall)cParametersAssignment_1_2_0_1.eContents().get(0);
		private final Group cGroup_1_2_0_2 = (Group)cGroup_1_2_0.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0_2_0 = (Keyword)cGroup_1_2_0_2.eContents().get(0);
		private final Assignment cParametersAssignment_1_2_0_2_1 = (Assignment)cGroup_1_2_0_2.eContents().get(1);
		private final RuleCall cParametersSelectorEntryParserRuleCall_1_2_0_2_1_0 = (RuleCall)cParametersAssignment_1_2_0_2_1.eContents().get(0);
		private final RuleCall cEndCommaParserRuleCall_1_2_0_3 = (RuleCall)cGroup_1_2_0.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_1_2_0_4 = (Keyword)cGroup_1_2_0.eContents().get(4);
		private final Assignment cParametersAssignment_1_2_1 = (Assignment)cAlternatives_1_2.eContents().get(1);
		private final RuleCall cParametersSelectorEntryParserRuleCall_1_2_1_0 = (RuleCall)cParametersAssignment_1_2_1.eContents().get(0);
		
		//SelectorExpression returns pp::Expression: // WAS: FunctionCall 
		//	AtExpression ({pp::SelectorExpression.leftExpr=current} "?" ("{" parameters+=SelectorEntry (","
		//	parameters+=SelectorEntry)* endComma? "}" | parameters+=SelectorEntry))?;
		public ParserRule getRule() { return rule; }

		//// WAS: FunctionCall 
		//AtExpression ({pp::SelectorExpression.leftExpr=current} "?" ("{" parameters+=SelectorEntry (","
		//parameters+=SelectorEntry)* endComma? "}" | parameters+=SelectorEntry))?
		public Group getGroup() { return cGroup; }

		//// WAS: FunctionCall 
		//AtExpression
		public RuleCall getAtExpressionParserRuleCall_0() { return cAtExpressionParserRuleCall_0; }

		//({pp::SelectorExpression.leftExpr=current} "?" ("{" parameters+=SelectorEntry ("," parameters+=SelectorEntry)* endComma?
		//"}" | parameters+=SelectorEntry))?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::SelectorExpression.leftExpr=current}
		public Action getSelectorExpressionLeftExprAction_1_0() { return cSelectorExpressionLeftExprAction_1_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//"{" parameters+=SelectorEntry ("," parameters+=SelectorEntry)* endComma? "}" | parameters+=SelectorEntry
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }

		//"{" parameters+=SelectorEntry ("," parameters+=SelectorEntry)* endComma? "}"
		public Group getGroup_1_2_0() { return cGroup_1_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_2_0_0() { return cLeftCurlyBracketKeyword_1_2_0_0; }

		//parameters+=SelectorEntry
		public Assignment getParametersAssignment_1_2_0_1() { return cParametersAssignment_1_2_0_1; }

		//SelectorEntry
		public RuleCall getParametersSelectorEntryParserRuleCall_1_2_0_1_0() { return cParametersSelectorEntryParserRuleCall_1_2_0_1_0; }

		//("," parameters+=SelectorEntry)*
		public Group getGroup_1_2_0_2() { return cGroup_1_2_0_2; }

		//","
		public Keyword getCommaKeyword_1_2_0_2_0() { return cCommaKeyword_1_2_0_2_0; }

		//parameters+=SelectorEntry
		public Assignment getParametersAssignment_1_2_0_2_1() { return cParametersAssignment_1_2_0_2_1; }

		//SelectorEntry
		public RuleCall getParametersSelectorEntryParserRuleCall_1_2_0_2_1_0() { return cParametersSelectorEntryParserRuleCall_1_2_0_2_1_0; }

		//endComma?
		public RuleCall getEndCommaParserRuleCall_1_2_0_3() { return cEndCommaParserRuleCall_1_2_0_3; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_2_0_4() { return cRightCurlyBracketKeyword_1_2_0_4; }

		//parameters+=SelectorEntry
		public Assignment getParametersAssignment_1_2_1() { return cParametersAssignment_1_2_1; }

		//SelectorEntry
		public RuleCall getParametersSelectorEntryParserRuleCall_1_2_1_0() { return cParametersSelectorEntryParserRuleCall_1_2_1_0; }
	}

	public class SelectorEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectorEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSelectorEntryLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExprExpressionParserRuleCall_1_2_0 = (RuleCall)cRightExprAssignment_1_2.eContents().get(0);
		
		//// VALIDATION  checks lhs is a valid selector left value
		//SelectorEntry returns pp::Expression:
		//	Expression ({pp::SelectorEntry.leftExpr=current} "=>" rightExpr=Expression)?;
		public ParserRule getRule() { return rule; }

		//Expression ({pp::SelectorEntry.leftExpr=current} "=>" rightExpr=Expression)?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//({pp::SelectorEntry.leftExpr=current} "=>" rightExpr=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::SelectorEntry.leftExpr=current}
		public Action getSelectorEntryLeftExprAction_1_0() { return cSelectorEntryLeftExprAction_1_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1_1() { return cEqualsSignGreaterThanSignKeyword_1_1; }

		//rightExpr=Expression
		public Assignment getRightExprAssignment_1_2() { return cRightExprAssignment_1_2; }

		//Expression
		public RuleCall getRightExprExpressionParserRuleCall_1_2_0() { return cRightExprExpressionParserRuleCall_1_2_0; }
	}

	public class AtExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAtExpressionLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cParametersAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_1_2_0_0 = (RuleCall)cParametersAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_1_2_1_1_0 = (RuleCall)cParametersAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//// Note: AtExpression serves dual purpose: ResourceReference and '#' access
		//// VALIDATION: checks 2 level nesting constraint on At a[x][y] is ok but not a[x][y][z] if bug compatible mode
		//// VALIDATION: checks At dual roles and validates accordingly (only single parameter for normal At) etc.	
		//AtExpression returns pp::Expression: // WAS: CollectExpression 
		//	FunctionCall ({pp::AtExpression.leftExpr=current} "[" (parameters+=Expression ("," parameters+=Expression)*)? "]")*;
		public ParserRule getRule() { return rule; }

		//// WAS: CollectExpression 
		//FunctionCall ({pp::AtExpression.leftExpr=current} "[" (parameters+=Expression ("," parameters+=Expression)*)? "]")*
		public Group getGroup() { return cGroup; }

		//// WAS: CollectExpression 
		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_0() { return cFunctionCallParserRuleCall_0; }

		//({pp::AtExpression.leftExpr=current} "[" (parameters+=Expression ("," parameters+=Expression)*)? "]")*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::AtExpression.leftExpr=current}
		public Action getAtExpressionLeftExprAction_1_0() { return cAtExpressionLeftExprAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//(parameters+=Expression ("," parameters+=Expression)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_2_0() { return cParametersAssignment_1_2_0; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_2_0_0() { return cParametersExpressionParserRuleCall_1_2_0_0; }

		//("," parameters+=Expression)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_2_1_1() { return cParametersAssignment_1_2_1_1; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_2_1_1_0() { return cParametersExpressionParserRuleCall_1_2_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFunctionCallLeftExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cParametersAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_1_2_0_0 = (RuleCall)cParametersAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_1_2_1_1_0 = (RuleCall)cParametersAssignment_1_2_1_1.eContents().get(0);
		private final RuleCall cEndCommaParserRuleCall_1_2_2 = (RuleCall)cGroup_1_2.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//// FunctionCall has different syntax restrictions depending on context
		//// - when used where only one expression can occur, parantheses are required around the arguments
		//// To solve this, the parser does NOT recognize func x as a function call, this is instead treated as
		//// a sequence of two expressions, a later step will need to determine if 'func' is a function, if so, how
		//// many arguments it is supposed to take, and then validate if the input is correct.
		////
		//// VALIDATION : functionExpr is a valid function name	
		//FunctionCall returns pp::Expression:
		//	PrimaryExpression ({pp::FunctionCall.leftExpr=current} "(" (parameters+=Expression ("," parameters+=Expression)*
		//	endComma?)? ")")?;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({pp::FunctionCall.leftExpr=current} "(" (parameters+=Expression ("," parameters+=Expression)*
		//endComma?)? ")")?
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({pp::FunctionCall.leftExpr=current} "(" (parameters+=Expression ("," parameters+=Expression)* endComma?)? ")")?
		public Group getGroup_1() { return cGroup_1; }

		//{pp::FunctionCall.leftExpr=current}
		public Action getFunctionCallLeftExprAction_1_0() { return cFunctionCallLeftExprAction_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//(parameters+=Expression ("," parameters+=Expression)* endComma?)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_2_0() { return cParametersAssignment_1_2_0; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_2_0_0() { return cParametersExpressionParserRuleCall_1_2_0_0; }

		//("," parameters+=Expression)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//","
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//parameters+=Expression
		public Assignment getParametersAssignment_1_2_1_1() { return cParametersAssignment_1_2_1_1; }

		//Expression
		public RuleCall getParametersExpressionParserRuleCall_1_2_1_1_0() { return cParametersExpressionParserRuleCall_1_2_1_1_0; }

		//endComma?
		public RuleCall getEndCommaParserRuleCall_1_2_2() { return cEndCommaParserRuleCall_1_2_2; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCaseExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cImportExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDefinitionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cHostClassDefinitionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNodeDefinitionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cVirtualNameOrReferenceParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cLiteralExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cVariableExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cParenthisedExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//PrimaryExpression returns pp::Expression:
		//	IfExpression | CaseExpression | ImportExpression | Definition | HostClassDefinition | NodeDefinition |
		//	VirtualNameOrReference | LiteralExpression | VariableExpression | ParenthisedExpression;
		public ParserRule getRule() { return rule; }

		//IfExpression | CaseExpression | ImportExpression | Definition | HostClassDefinition | NodeDefinition |
		//VirtualNameOrReference | LiteralExpression | VariableExpression | ParenthisedExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//IfExpression
		public RuleCall getIfExpressionParserRuleCall_0() { return cIfExpressionParserRuleCall_0; }

		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_1() { return cCaseExpressionParserRuleCall_1; }

		//ImportExpression
		public RuleCall getImportExpressionParserRuleCall_2() { return cImportExpressionParserRuleCall_2; }

		//Definition
		public RuleCall getDefinitionParserRuleCall_3() { return cDefinitionParserRuleCall_3; }

		//HostClassDefinition
		public RuleCall getHostClassDefinitionParserRuleCall_4() { return cHostClassDefinitionParserRuleCall_4; }

		//NodeDefinition
		public RuleCall getNodeDefinitionParserRuleCall_5() { return cNodeDefinitionParserRuleCall_5; }

		//VirtualNameOrReference
		public RuleCall getVirtualNameOrReferenceParserRuleCall_6() { return cVirtualNameOrReferenceParserRuleCall_6; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_7() { return cLiteralExpressionParserRuleCall_7; }

		//VariableExpression
		public RuleCall getVariableExpressionParserRuleCall_8() { return cVariableExpressionParserRuleCall_8; }

		//ParenthisedExpression
		public RuleCall getParenthisedExpressionParserRuleCall_9() { return cParenthisedExpressionParserRuleCall_9; }
	}

	public class NodeDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHostNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHostNamesHostReferenceParserRuleCall_1_0 = (RuleCall)cHostNamesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cHostNamesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cHostNamesHostReferenceParserRuleCall_2_1_0 = (RuleCall)cHostNamesAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cInheritsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParentNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParentNameHostReferenceParserRuleCall_3_1_0 = (RuleCall)cParentNameAssignment_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementsExpressionListParserRuleCall_5_0 = (RuleCall)cStatementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//NodeDefinition returns pp::NodeDefinition:
		//	"node" hostNames+=HostReference ("," hostNames+=HostReference)* ("inherits" parentName=HostReference)? "{"
		//	statements+=ExpressionList* "}";
		public ParserRule getRule() { return rule; }

		//"node" hostNames+=HostReference ("," hostNames+=HostReference)* ("inherits" parentName=HostReference)? "{"
		//statements+=ExpressionList* "}"
		public Group getGroup() { return cGroup; }

		//"node"
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }

		//hostNames+=HostReference
		public Assignment getHostNamesAssignment_1() { return cHostNamesAssignment_1; }

		//HostReference
		public RuleCall getHostNamesHostReferenceParserRuleCall_1_0() { return cHostNamesHostReferenceParserRuleCall_1_0; }

		//("," hostNames+=HostReference)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//hostNames+=HostReference
		public Assignment getHostNamesAssignment_2_1() { return cHostNamesAssignment_2_1; }

		//HostReference
		public RuleCall getHostNamesHostReferenceParserRuleCall_2_1_0() { return cHostNamesHostReferenceParserRuleCall_2_1_0; }

		//("inherits" parentName=HostReference)?
		public Group getGroup_3() { return cGroup_3; }

		//"inherits"
		public Keyword getInheritsKeyword_3_0() { return cInheritsKeyword_3_0; }

		//parentName=HostReference
		public Assignment getParentNameAssignment_3_1() { return cParentNameAssignment_3_1; }

		//HostReference
		public RuleCall getParentNameHostReferenceParserRuleCall_3_1_0() { return cParentNameHostReferenceParserRuleCall_3_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_5() { return cStatementsAssignment_5; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_5_0() { return cStatementsExpressionListParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class HostReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HostReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralRegexParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralDefaultParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralNameOrReferenceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//HostReference returns pp::Expression:
		//	StringExpression | LiteralRegex | LiteralDefault | LiteralNameOrReference;
		public ParserRule getRule() { return rule; }

		//StringExpression | LiteralRegex | LiteralDefault | LiteralNameOrReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_0() { return cStringExpressionParserRuleCall_0; }

		//LiteralRegex
		public RuleCall getLiteralRegexParserRuleCall_1() { return cLiteralRegexParserRuleCall_1; }

		//LiteralDefault
		public RuleCall getLiteralDefaultParserRuleCall_2() { return cLiteralDefaultParserRuleCall_2; }

		//LiteralNameOrReference
		public RuleCall getLiteralNameOrReferenceParserRuleCall_3() { return cLiteralNameOrReferenceParserRuleCall_3; }
	}

	public class HostClassDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HostClassDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClassNameUnionNameOrReferenceParserRuleCall_1_0 = (RuleCall)cClassNameAssignment_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentsDefinitionArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cInheritsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParentParentNameParserRuleCall_3_1_0 = (RuleCall)cParentAssignment_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cStatementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cStatementsExpressionListParserRuleCall_5_0 = (RuleCall)cStatementsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//HostClassDefinition returns pp::HostClassDefinition:
		//	"class" className=unionNameOrReference arguments=DefinitionArgumentList? ("inherits" parent=ParentName)? "{"
		//	statements+=ExpressionList* "}";
		public ParserRule getRule() { return rule; }

		//"class" className=unionNameOrReference arguments=DefinitionArgumentList? ("inherits" parent=ParentName)? "{"
		//statements+=ExpressionList* "}"
		public Group getGroup() { return cGroup; }

		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }

		//className=unionNameOrReference
		public Assignment getClassNameAssignment_1() { return cClassNameAssignment_1; }

		//unionNameOrReference
		public RuleCall getClassNameUnionNameOrReferenceParserRuleCall_1_0() { return cClassNameUnionNameOrReferenceParserRuleCall_1_0; }

		//arguments=DefinitionArgumentList?
		public Assignment getArgumentsAssignment_2() { return cArgumentsAssignment_2; }

		//DefinitionArgumentList
		public RuleCall getArgumentsDefinitionArgumentListParserRuleCall_2_0() { return cArgumentsDefinitionArgumentListParserRuleCall_2_0; }

		//("inherits" parent=ParentName)?
		public Group getGroup_3() { return cGroup_3; }

		//"inherits"
		public Keyword getInheritsKeyword_3_0() { return cInheritsKeyword_3_0; }

		//parent=ParentName
		public Assignment getParentAssignment_3_1() { return cParentAssignment_3_1; }

		//ParentName
		public RuleCall getParentParentNameParserRuleCall_3_1_0() { return cParentParentNameParserRuleCall_3_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_5() { return cStatementsAssignment_5; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_5_0() { return cStatementsExpressionListParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class ParentNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParentName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralDefaultParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralNameOrReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ParentName returns pp::LiteralExpression:
		//	LiteralDefault | LiteralNameOrReference;
		public ParserRule getRule() { return rule; }

		//LiteralDefault | LiteralNameOrReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralDefault
		public RuleCall getLiteralDefaultParserRuleCall_0() { return cLiteralDefaultParserRuleCall_0; }

		//LiteralNameOrReference
		public RuleCall getLiteralNameOrReferenceParserRuleCall_1() { return cLiteralNameOrReferenceParserRuleCall_1; }
	}

	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cClassNameUnionNameOrReferenceParserRuleCall_1_0 = (RuleCall)cClassNameAssignment_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentsDefinitionArgumentListParserRuleCall_2_0 = (RuleCall)cArgumentsAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementsExpressionListParserRuleCall_4_0 = (RuleCall)cStatementsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Definition returns pp::Definition:
		//	"define" className=unionNameOrReference arguments=DefinitionArgumentList? "{" statements+=ExpressionList* "}";
		public ParserRule getRule() { return rule; }

		//"define" className=unionNameOrReference arguments=DefinitionArgumentList? "{" statements+=ExpressionList* "}"
		public Group getGroup() { return cGroup; }

		//"define"
		public Keyword getDefineKeyword_0() { return cDefineKeyword_0; }

		//className=unionNameOrReference
		public Assignment getClassNameAssignment_1() { return cClassNameAssignment_1; }

		//unionNameOrReference
		public RuleCall getClassNameUnionNameOrReferenceParserRuleCall_1_0() { return cClassNameUnionNameOrReferenceParserRuleCall_1_0; }

		//arguments=DefinitionArgumentList?
		public Assignment getArgumentsAssignment_2() { return cArgumentsAssignment_2; }

		//DefinitionArgumentList
		public RuleCall getArgumentsDefinitionArgumentListParserRuleCall_2_0() { return cArgumentsDefinitionArgumentListParserRuleCall_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_4() { return cStatementsAssignment_4; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_4_0() { return cStatementsExpressionListParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class DefinitionArgumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefinitionArgumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDefinitionArgumentListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgumentsDefinitionArgumentParserRuleCall_2_0_0 = (RuleCall)cArgumentsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgumentsDefinitionArgumentParserRuleCall_2_1_1_0 = (RuleCall)cArgumentsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cEndCommaParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//DefinitionArgumentList returns pp::DefinitionArgumentList:
		//	{pp::DefinitionArgumentList} "(" (arguments+=DefinitionArgument ("," arguments+=DefinitionArgument)*)? endComma? ")";
		public ParserRule getRule() { return rule; }

		//{pp::DefinitionArgumentList} "(" (arguments+=DefinitionArgument ("," arguments+=DefinitionArgument)*)? endComma? ")"
		public Group getGroup() { return cGroup; }

		//{pp::DefinitionArgumentList}
		public Action getDefinitionArgumentListAction_0() { return cDefinitionArgumentListAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(arguments+=DefinitionArgument ("," arguments+=DefinitionArgument)*)?
		public Group getGroup_2() { return cGroup_2; }

		//arguments+=DefinitionArgument
		public Assignment getArgumentsAssignment_2_0() { return cArgumentsAssignment_2_0; }

		//DefinitionArgument
		public RuleCall getArgumentsDefinitionArgumentParserRuleCall_2_0_0() { return cArgumentsDefinitionArgumentParserRuleCall_2_0_0; }

		//("," arguments+=DefinitionArgument)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//arguments+=DefinitionArgument
		public Assignment getArgumentsAssignment_2_1_1() { return cArgumentsAssignment_2_1_1; }

		//DefinitionArgument
		public RuleCall getArgumentsDefinitionArgumentParserRuleCall_2_1_1_0() { return cArgumentsDefinitionArgumentParserRuleCall_2_1_1_0; }

		//endComma?
		public RuleCall getEndCommaParserRuleCall_3() { return cEndCommaParserRuleCall_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class DefinitionArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DefinitionArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cArgNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cArgNameUNION_VARIABLE_OR_NAMEParserRuleCall_0_0 = (RuleCall)cArgNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0 = (Assignment)cAlternatives_1_0.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_0_0_0 = (Keyword)cOpAssignment_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cAlternatives_1_0.eContents().get(1);
		private final Keyword cOpEqualsSignGreaterThanSignKeyword_1_0_1_0 = (Keyword)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//// VALIDATION: Depracted warning if name does not start with $
		//// VALIDATION: Not all variations of SimplefiedVariableOrName are valid (with NS)
		//// VALIDATION: value expr is RVALUE
		//// 	
		//DefinitionArgument returns pp::DefinitionArgument:
		//	argName=UNION_VARIABLE_OR_NAME ((op="=" | op="=>") value=Expression)?;
		public ParserRule getRule() { return rule; }

		//argName=UNION_VARIABLE_OR_NAME ((op="=" | op="=>") value=Expression)?
		public Group getGroup() { return cGroup; }

		//argName=UNION_VARIABLE_OR_NAME
		public Assignment getArgNameAssignment_0() { return cArgNameAssignment_0; }

		//UNION_VARIABLE_OR_NAME
		public RuleCall getArgNameUNION_VARIABLE_OR_NAMEParserRuleCall_0_0() { return cArgNameUNION_VARIABLE_OR_NAMEParserRuleCall_0_0; }

		//((op="=" | op="=>") value=Expression)?
		public Group getGroup_1() { return cGroup_1; }

		//op="=" | op="=>"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//op="="
		public Assignment getOpAssignment_1_0_0() { return cOpAssignment_1_0_0; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_0_0_0() { return cOpEqualsSignKeyword_1_0_0_0; }

		//op="=>"
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//"=>"
		public Keyword getOpEqualsSignGreaterThanSignKeyword_1_0_1_0() { return cOpEqualsSignGreaterThanSignKeyword_1_0_1_0; }

		//value=Expression
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_1_0() { return cValueExpressionParserRuleCall_1_1_0; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSwitchExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSwitchExprExpressionParserRuleCall_1_0 = (RuleCall)cSwitchExprAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesCaseParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////-- CASE
		////
		//CaseExpression returns pp::CaseExpression:
		//	"case" switchExpr=Expression "{" cases+=Case* "}";
		public ParserRule getRule() { return rule; }

		//"case" switchExpr=Expression "{" cases+=Case* "}"
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//switchExpr=Expression
		public Assignment getSwitchExprAssignment_1() { return cSwitchExprAssignment_1; }

		//Expression
		public RuleCall getSwitchExprExpressionParserRuleCall_1_0() { return cSwitchExprExpressionParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//cases+=Case*
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }

		//Case
		public RuleCall getCasesCaseParserRuleCall_3_0() { return cCasesCaseParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValuesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValuesExpressionParserRuleCall_0_0 = (RuleCall)cValuesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValuesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValuesExpressionParserRuleCall_1_1_0 = (RuleCall)cValuesAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementsExpressionListParserRuleCall_4_0 = (RuleCall)cStatementsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Case returns pp::Case:
		//	values+=Expression ("," values+=Expression)* ":" "{" statements+=ExpressionList* "}";
		public ParserRule getRule() { return rule; }

		//values+=Expression ("," values+=Expression)* ":" "{" statements+=ExpressionList* "}"
		public Group getGroup() { return cGroup; }

		//values+=Expression
		public Assignment getValuesAssignment_0() { return cValuesAssignment_0; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_0_0() { return cValuesExpressionParserRuleCall_0_0; }

		//("," values+=Expression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//values+=Expression
		public Assignment getValuesAssignment_1_1() { return cValuesAssignment_1_1; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_1_1_0() { return cValuesExpressionParserRuleCall_1_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_4() { return cStatementsAssignment_4; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_4_0() { return cStatementsExpressionListParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class IfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCondExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCondExprExpressionParserRuleCall_1_0 = (RuleCall)cCondExprAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenStatementsExpressionListParserRuleCall_3_0 = (RuleCall)cThenStatementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Group cGroup_5_0 = (Group)cAlternatives_5.eContents().get(0);
		private final Keyword cElsifKeyword_5_0_0 = (Keyword)cGroup_5_0.eContents().get(0);
		private final Assignment cElseStatementAssignment_5_0_1 = (Assignment)cGroup_5_0.eContents().get(1);
		private final RuleCall cElseStatementElseIfExpressionParserRuleCall_5_0_1_0 = (RuleCall)cElseStatementAssignment_5_0_1.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseStatementAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseStatementElseExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseStatementAssignment_5_1_1.eContents().get(0);
		
		////-- IF 
		////
		//// VALIDATION: checks that the elseStatement is an Else of Elsif, and validate that Else or Elsif
		//// only appears as parented by If, Else or Elseif
		//IfExpression returns pp::IfExpression:
		//	"if" condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif" elseStatement=ElseIfExpression | "else"
		//	elseStatement=ElseExpression)?;
		public ParserRule getRule() { return rule; }

		//"if" condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif" elseStatement=ElseIfExpression | "else"
		//elseStatement=ElseExpression)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1() { return cCondExprAssignment_1; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_0() { return cCondExprExpressionParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//thenStatements+=ExpressionList*
		public Assignment getThenStatementsAssignment_3() { return cThenStatementsAssignment_3; }

		//ExpressionList
		public RuleCall getThenStatementsExpressionListParserRuleCall_3_0() { return cThenStatementsExpressionListParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//(=> "elsif" elseStatement=ElseIfExpression | "else" elseStatement=ElseExpression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//=> "elsif" elseStatement=ElseIfExpression
		public Group getGroup_5_0() { return cGroup_5_0; }

		//=> "elsif"
		public Keyword getElsifKeyword_5_0_0() { return cElsifKeyword_5_0_0; }

		//elseStatement=ElseIfExpression
		public Assignment getElseStatementAssignment_5_0_1() { return cElseStatementAssignment_5_0_1; }

		//ElseIfExpression
		public RuleCall getElseStatementElseIfExpressionParserRuleCall_5_0_1_0() { return cElseStatementElseIfExpressionParserRuleCall_5_0_1_0; }

		//=> "else" elseStatement=ElseExpression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//=> "else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseStatement=ElseExpression
		public Assignment getElseStatementAssignment_5_1_1() { return cElseStatementAssignment_5_1_1; }

		//ElseExpression
		public RuleCall getElseStatementElseExpressionParserRuleCall_5_1_1_0() { return cElseStatementElseExpressionParserRuleCall_5_1_1_0; }
	}

	public class ElseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElseExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsExpressionListParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ElseExpression returns pp::Expression:
		//	{pp::ElseExpression} "{" statements+=ExpressionList* "}";
		public ParserRule getRule() { return rule; }

		//{pp::ElseExpression} "{" statements+=ExpressionList* "}"
		public Group getGroup() { return cGroup; }

		//{pp::ElseExpression}
		public Action getElseExpressionAction_0() { return cElseExpressionAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statements+=ExpressionList*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//ExpressionList
		public RuleCall getStatementsExpressionListParserRuleCall_2_0() { return cStatementsExpressionListParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ElseIfExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseIfExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElseIfExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCondExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCondExprExpressionParserRuleCall_1_0 = (RuleCall)cCondExprAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenStatementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenStatementsExpressionListParserRuleCall_3_0 = (RuleCall)cThenStatementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Group cGroup_5_0 = (Group)cAlternatives_5.eContents().get(0);
		private final Keyword cElsifKeyword_5_0_0 = (Keyword)cGroup_5_0.eContents().get(0);
		private final Assignment cElseStatementAssignment_5_0_1 = (Assignment)cGroup_5_0.eContents().get(1);
		private final RuleCall cElseStatementElseIfExpressionParserRuleCall_5_0_1_0 = (RuleCall)cElseStatementAssignment_5_0_1.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cAlternatives_5.eContents().get(1);
		private final Keyword cElseKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cElseStatementAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cElseStatementElseExpressionParserRuleCall_5_1_1_0 = (RuleCall)cElseStatementAssignment_5_1_1.eContents().get(0);
		
		//ElseIfExpression returns pp::Expression:
		//	{pp::ElseIfExpression} condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif"
		//	elseStatement=ElseIfExpression | "else" elseStatement=ElseExpression)?;
		public ParserRule getRule() { return rule; }

		//{pp::ElseIfExpression} condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif"
		//elseStatement=ElseIfExpression | "else" elseStatement=ElseExpression)?
		public Group getGroup() { return cGroup; }

		//{pp::ElseIfExpression}
		public Action getElseIfExpressionAction_0() { return cElseIfExpressionAction_0; }

		//condExpr=Expression
		public Assignment getCondExprAssignment_1() { return cCondExprAssignment_1; }

		//Expression
		public RuleCall getCondExprExpressionParserRuleCall_1_0() { return cCondExprExpressionParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//thenStatements+=ExpressionList*
		public Assignment getThenStatementsAssignment_3() { return cThenStatementsAssignment_3; }

		//ExpressionList
		public RuleCall getThenStatementsExpressionListParserRuleCall_3_0() { return cThenStatementsExpressionListParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//(=> "elsif" elseStatement=ElseIfExpression | "else" elseStatement=ElseExpression)?
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//=> "elsif" elseStatement=ElseIfExpression
		public Group getGroup_5_0() { return cGroup_5_0; }

		//=> "elsif"
		public Keyword getElsifKeyword_5_0_0() { return cElsifKeyword_5_0_0; }

		//elseStatement=ElseIfExpression
		public Assignment getElseStatementAssignment_5_0_1() { return cElseStatementAssignment_5_0_1; }

		//ElseIfExpression
		public RuleCall getElseStatementElseIfExpressionParserRuleCall_5_0_1_0() { return cElseStatementElseIfExpressionParserRuleCall_5_0_1_0; }

		//=> "else" elseStatement=ElseExpression
		public Group getGroup_5_1() { return cGroup_5_1; }

		//=> "else"
		public Keyword getElseKeyword_5_1_0() { return cElseKeyword_5_1_0; }

		//elseStatement=ElseExpression
		public Assignment getElseStatementAssignment_5_1_1() { return cElseStatementAssignment_5_1_1; }

		//ElseExpression
		public RuleCall getElseStatementElseExpressionParserRuleCall_5_1_1_0() { return cElseStatementElseExpressionParserRuleCall_5_1_1_0; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralBooleanParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralUndefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralDefaultParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralListParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLiteralHashParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cLiteralRegexParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cStringExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cLiteralNameOrReferenceParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//LiteralExpression returns pp::Expression:
		//	LiteralBoolean | LiteralUndef | LiteralDefault | LiteralList | LiteralHash | LiteralRegex | StringExpression |
		//	LiteralNameOrReference;
		public ParserRule getRule() { return rule; }

		//LiteralBoolean | LiteralUndef | LiteralDefault | LiteralList | LiteralHash | LiteralRegex | StringExpression |
		//LiteralNameOrReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralBoolean
		public RuleCall getLiteralBooleanParserRuleCall_0() { return cLiteralBooleanParserRuleCall_0; }

		//LiteralUndef
		public RuleCall getLiteralUndefParserRuleCall_1() { return cLiteralUndefParserRuleCall_1; }

		//LiteralDefault
		public RuleCall getLiteralDefaultParserRuleCall_2() { return cLiteralDefaultParserRuleCall_2; }

		//LiteralList
		public RuleCall getLiteralListParserRuleCall_3() { return cLiteralListParserRuleCall_3; }

		//LiteralHash
		public RuleCall getLiteralHashParserRuleCall_4() { return cLiteralHashParserRuleCall_4; }

		//LiteralRegex
		public RuleCall getLiteralRegexParserRuleCall_5() { return cLiteralRegexParserRuleCall_5; }

		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_6() { return cStringExpressionParserRuleCall_6; }

		//LiteralNameOrReference
		public RuleCall getLiteralNameOrReferenceParserRuleCall_7() { return cLiteralNameOrReferenceParserRuleCall_7; }
	}

	public class LiteralNameOrReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralNameOrReference");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueUnionNameOrReferenceParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LiteralNameOrReference returns pp::LiteralNameOrReference:
		//	value=unionNameOrReference;
		public ParserRule getRule() { return rule; }

		//value=unionNameOrReference
		public Assignment getValueAssignment() { return cValueAssignment; }

		//unionNameOrReference
		public RuleCall getValueUnionNameOrReferenceParserRuleCall_0() { return cValueUnionNameOrReferenceParserRuleCall_0; }
	}

	public class UNION_VARIABLE_OR_NAMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UNION_VARIABLE_OR_NAME");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDollarSignKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final RuleCall cUnionNameOrReferenceParserRuleCall_0_1_0 = (RuleCall)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cKeywordParserRuleCall_0_1_1 = (RuleCall)cAlternatives_0_1.eContents().get(1);
		private final RuleCall cUnionNameOrReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//UNION_VARIABLE_OR_NAME:
		//	"$" (unionNameOrReference | keyword) | unionNameOrReference;
		public ParserRule getRule() { return rule; }

		//"$" (unionNameOrReference | keyword) | unionNameOrReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//"$" (unionNameOrReference | keyword)
		public Group getGroup_0() { return cGroup_0; }

		//"$"
		public Keyword getDollarSignKeyword_0_0() { return cDollarSignKeyword_0_0; }

		//unionNameOrReference | keyword
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//unionNameOrReference
		public RuleCall getUnionNameOrReferenceParserRuleCall_0_1_0() { return cUnionNameOrReferenceParserRuleCall_0_1_0; }

		//keyword
		public RuleCall getKeywordParserRuleCall_0_1_1() { return cKeywordParserRuleCall_0_1_1; }

		//unionNameOrReference
		public RuleCall getUnionNameOrReferenceParserRuleCall_1() { return cUnionNameOrReferenceParserRuleCall_1; }
	}

	public class ParenthisedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthisedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cParenthesisedExpressionAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// validate that expr is not empty	
		//ParenthisedExpression returns pp::ParenthesisedExpression:
		//	"(" {pp::ParenthesisedExpression} expr=Expression? ")";
		public ParserRule getRule() { return rule; }

		//"(" {pp::ParenthesisedExpression} expr=Expression? ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//{pp::ParenthesisedExpression}
		public Action getParenthesisedExpressionAction_1() { return cParenthesisedExpressionAction_1; }

		//expr=Expression?
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class VirtualNameOrReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VirtualNameOrReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommercialAtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExportedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExportedATBooleanParserRuleCall_1_0 = (RuleCall)cExportedAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueUnionNameOrReferenceParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//VirtualNameOrReference returns pp::VirtualNameOrReference:
		//	"@" exported=ATBoolean? value=unionNameOrReference;
		public ParserRule getRule() { return rule; }

		//"@" exported=ATBoolean? value=unionNameOrReference
		public Group getGroup() { return cGroup; }

		//"@"
		public Keyword getCommercialAtKeyword_0() { return cCommercialAtKeyword_0; }

		//exported=ATBoolean?
		public Assignment getExportedAssignment_1() { return cExportedAssignment_1; }

		//ATBoolean
		public RuleCall getExportedATBooleanParserRuleCall_1_0() { return cExportedATBooleanParserRuleCall_1_0; }

		//value=unionNameOrReference
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//unionNameOrReference
		public RuleCall getValueUnionNameOrReferenceParserRuleCall_2_0() { return cValueUnionNameOrReferenceParserRuleCall_2_0; }
	}

	public class ATBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ATBoolean");
		private final Keyword cCommercialAtKeyword = (Keyword)rule.eContents().get(1);
		
		//// Kludge for a serialization issue using exported = '@'?
		//// Note: has value converter
		//ATBoolean returns ecore::EBoolean:
		//	"@";
		public ParserRule getRule() { return rule; }

		//"@"
		public Keyword getCommercialAtKeyword() { return cCommercialAtKeyword; }
	}

	public class ImportExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImportExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cImportExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cImportKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValuesQuotedStringParserRuleCall_2_0_0 = (RuleCall)cValuesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValuesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValuesQuotedStringParserRuleCall_2_1_1_0 = (RuleCall)cValuesAssignment_2_1_1.eContents().get(0);
		
		//// VALIDATION: No interpolation takes place in DoubleQuotedStrings, a warning will be issued.
		//// VALIDATION: Checks that import has at least one thing to import	
		//ImportExpression returns pp::ImportExpression:
		//	{pp::ImportExpression} "import" (values+=QuotedString ("," values+=QuotedString)*)?;
		public ParserRule getRule() { return rule; }

		//{pp::ImportExpression} "import" (values+=QuotedString ("," values+=QuotedString)*)?
		public Group getGroup() { return cGroup; }

		//{pp::ImportExpression}
		public Action getImportExpressionAction_0() { return cImportExpressionAction_0; }

		//"import"
		public Keyword getImportKeyword_1() { return cImportKeyword_1; }

		//(values+=QuotedString ("," values+=QuotedString)*)?
		public Group getGroup_2() { return cGroup_2; }

		//values+=QuotedString
		public Assignment getValuesAssignment_2_0() { return cValuesAssignment_2_0; }

		//QuotedString
		public RuleCall getValuesQuotedStringParserRuleCall_2_0_0() { return cValuesQuotedStringParserRuleCall_2_0_0; }

		//("," values+=QuotedString)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//values+=QuotedString
		public Assignment getValuesAssignment_2_1_1() { return cValuesAssignment_2_1_1; }

		//QuotedString
		public RuleCall getValuesQuotedStringParserRuleCall_2_1_1_0() { return cValuesQuotedStringParserRuleCall_2_1_1_0; }
	}

	public class LiteralListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralListAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cElementsExpressionParserRuleCall_2_0_0 = (RuleCall)cElementsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cElementsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cElementsExpressionParserRuleCall_2_1_1_0 = (RuleCall)cElementsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cEndCommaParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//LiteralList returns pp::LiteralList:
		//	{pp::LiteralList} "[" (elements+=Expression ("," elements+=Expression)*)? endComma? "]";
		public ParserRule getRule() { return rule; }

		//{pp::LiteralList} "[" (elements+=Expression ("," elements+=Expression)*)? endComma? "]"
		public Group getGroup() { return cGroup; }

		//{pp::LiteralList}
		public Action getLiteralListAction_0() { return cLiteralListAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//(elements+=Expression ("," elements+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//elements+=Expression
		public Assignment getElementsAssignment_2_0() { return cElementsAssignment_2_0; }

		//Expression
		public RuleCall getElementsExpressionParserRuleCall_2_0_0() { return cElementsExpressionParserRuleCall_2_0_0; }

		//("," elements+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//elements+=Expression
		public Assignment getElementsAssignment_2_1_1() { return cElementsAssignment_2_1_1; }

		//Expression
		public RuleCall getElementsExpressionParserRuleCall_2_1_1_0() { return cElementsExpressionParserRuleCall_2_1_1_0; }

		//endComma?
		public RuleCall getEndCommaParserRuleCall_3() { return cEndCommaParserRuleCall_3; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class LiteralHashElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralHash");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralHashAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cElementsHashEntryParserRuleCall_2_0_0 = (RuleCall)cElementsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cElementsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cElementsHashEntryParserRuleCall_2_1_1_0 = (RuleCall)cElementsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cEndCommaParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//LiteralHash returns pp::LiteralHash:
		//	{pp::LiteralHash} "{" (elements+=HashEntry ("," elements+=HashEntry)*)? endComma? "}";
		public ParserRule getRule() { return rule; }

		//{pp::LiteralHash} "{" (elements+=HashEntry ("," elements+=HashEntry)*)? endComma? "}"
		public Group getGroup() { return cGroup; }

		//{pp::LiteralHash}
		public Action getLiteralHashAction_0() { return cLiteralHashAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//(elements+=HashEntry ("," elements+=HashEntry)*)?
		public Group getGroup_2() { return cGroup_2; }

		//elements+=HashEntry
		public Assignment getElementsAssignment_2_0() { return cElementsAssignment_2_0; }

		//HashEntry
		public RuleCall getElementsHashEntryParserRuleCall_2_0_0() { return cElementsHashEntryParserRuleCall_2_0_0; }

		//("," elements+=HashEntry)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//elements+=HashEntry
		public Assignment getElementsAssignment_2_1_1() { return cElementsAssignment_2_1_1; }

		//HashEntry
		public RuleCall getElementsHashEntryParserRuleCall_2_1_1_0() { return cElementsHashEntryParserRuleCall_2_1_1_0; }

		//endComma?
		public RuleCall getEndCommaParserRuleCall_3() { return cEndCommaParserRuleCall_3; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class HashEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HashEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyLiteralNameOrStringParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// Use LiteralNameOrString to get different literals (to preserve quotes) as opposed to just the token value.
		//// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
		//HashEntry returns pp::HashEntry:
		//	key=LiteralNameOrString "=>" value=Expression;
		public ParserRule getRule() { return rule; }

		//key=LiteralNameOrString "=>" value=Expression
		public Group getGroup() { return cGroup; }

		//key=LiteralNameOrString
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//LiteralNameOrString
		public RuleCall getKeyLiteralNameOrStringParserRuleCall_0_0() { return cKeyLiteralNameOrStringParserRuleCall_0_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1() { return cEqualsSignGreaterThanSignKeyword_1; }

		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}

	public class LiteralNameOrStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralNameOrString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLiteralNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
		//LiteralNameOrString returns pp::Expression:
		//	StringExpression | LiteralName;
		public ParserRule getRule() { return rule; }

		//StringExpression | LiteralName
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_0() { return cStringExpressionParserRuleCall_0; }

		//LiteralName
		public RuleCall getLiteralNameParserRuleCall_1() { return cLiteralNameParserRuleCall_1; }
	}

	public class BooleanValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// has converter
		//BooleanValue returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class LiteralBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralBoolean");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBooleanValueParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//LiteralBoolean returns pp::LiteralBoolean:
		//	value=BooleanValue;
		public ParserRule getRule() { return rule; }

		//value=BooleanValue
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BooleanValue
		public RuleCall getValueBooleanValueParserRuleCall_0() { return cValueBooleanValueParserRuleCall_0; }
	}

	public class LiteralDefaultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralDefault");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralDefaultAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDefaultKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LiteralDefault returns pp::LiteralDefault:
		//	{pp::LiteralDefault} "default";
		public ParserRule getRule() { return rule; }

		//{pp::LiteralDefault} "default"
		public Group getGroup() { return cGroup; }

		//{pp::LiteralDefault}
		public Action getLiteralDefaultAction_0() { return cLiteralDefaultAction_0; }

		//"default"
		public Keyword getDefaultKeyword_1() { return cDefaultKeyword_1; }
	}

	public class LiteralUndefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralUndef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLiteralUndefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cUndefKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LiteralUndef returns pp::LiteralUndef:
		//	{pp::LiteralUndef} "undef";
		public ParserRule getRule() { return rule; }

		//{pp::LiteralUndef} "undef"
		public Group getGroup() { return cGroup; }

		//{pp::LiteralUndef}
		public Action getLiteralUndefAction_0() { return cLiteralUndefAction_0; }

		//"undef"
		public Keyword getUndefKeyword_1() { return cUndefKeyword_1; }
	}

	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSingleQuotedStringParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnquotedStringParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDoubleQuotedStringParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//StringExpression returns pp::Expression hidden(WS, SL_COMMENT, ML_COMMENT):
		//	SingleQuotedString | UnquotedString | DoubleQuotedString;
		public ParserRule getRule() { return rule; }

		//SingleQuotedString | UnquotedString | DoubleQuotedString
		public Alternatives getAlternatives() { return cAlternatives; }

		//SingleQuotedString
		public RuleCall getSingleQuotedStringParserRuleCall_0() { return cSingleQuotedStringParserRuleCall_0; }

		//UnquotedString
		public RuleCall getUnquotedStringParserRuleCall_1() { return cUnquotedStringParserRuleCall_1; }

		//DoubleQuotedString
		public RuleCall getDoubleQuotedStringParserRuleCall_2() { return cDoubleQuotedStringParserRuleCall_2; }
	}

	public class QuotedStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuotedString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDoubleQuotedStringParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSingleQuotedStringParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//QuotedString returns pp::IQuotedString hidden(WS, SL_COMMENT, ML_COMMENT):
		//	DoubleQuotedString | SingleQuotedString;
		public ParserRule getRule() { return rule; }

		//DoubleQuotedString | SingleQuotedString
		public Alternatives getAlternatives() { return cAlternatives; }

		//DoubleQuotedString
		public RuleCall getDoubleQuotedStringParserRuleCall_0() { return cDoubleQuotedStringParserRuleCall_0; }

		//SingleQuotedString
		public RuleCall getSingleQuotedStringParserRuleCall_1() { return cSingleQuotedStringParserRuleCall_1; }
	}

	public class SingleQuotedStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SingleQuotedString");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSingleQuotedStringAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextSqTextParserRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//SingleQuotedString returns pp::SingleQuotedString:
		//	{pp::SingleQuotedString} text=sqText;
		public ParserRule getRule() { return rule; }

		//{pp::SingleQuotedString} text=sqText
		public Group getGroup() { return cGroup; }

		//{pp::SingleQuotedString}
		public Action getSingleQuotedStringAction_0() { return cSingleQuotedStringAction_0; }

		//text=sqText
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }

		//sqText
		public RuleCall getTextSqTextParserRuleCall_1_0() { return cTextSqTextParserRuleCall_1_0; }
	}

	public class DQT_DOLLARElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DQT_DOLLAR");
		private final Keyword cDollarSignKeyword = (Keyword)rule.eContents().get(1);
		
		//// Special declarations to aid syntax coloring of a $ in a special place.	
		//DQT_DOLLAR:
		//	"$";
		public ParserRule getRule() { return rule; }

		//"$"
		public Keyword getDollarSignKeyword() { return cDollarSignKeyword; }
	}

	public class DoubleQuotedStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoubleQuotedString");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTextExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextExpressionTextExpressionParserRuleCall_1_0 = (RuleCall)cTextExpressionAssignment_1.eContents().get(0);
		private final Keyword cQuotationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Double quoted string with expression interpolation
		//// handles:
		//// - $ <non variable char or {> is a verbatim $ included in the string
		//// - $varname - evaluated and included in the string
		//// - ${ expression } - evaluated and included in the string
		////
		//DoubleQuotedString returns pp::DoubleQuotedString hidden():
		//	"\"" textExpression=TextExpression "\"";
		public ParserRule getRule() { return rule; }

		//"\"" textExpression=TextExpression "\""
		public Group getGroup() { return cGroup; }

		//"\""
		public Keyword getQuotationMarkKeyword_0() { return cQuotationMarkKeyword_0; }

		//textExpression=TextExpression
		public Assignment getTextExpressionAssignment_1() { return cTextExpressionAssignment_1; }

		//TextExpression
		public RuleCall getTextExpressionTextExpressionParserRuleCall_1_0() { return cTextExpressionTextExpressionParserRuleCall_1_0; }

		//"\""
		public Keyword getQuotationMarkKeyword_2() { return cQuotationMarkKeyword_2; }
	}

	public class TextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TextExpression");
		private final RuleCall cDollarTextExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Lowest precedence TextExpression
		//TextExpression returns pp::TextExpression hidden():
		//	DollarTextExpression;
		public ParserRule getRule() { return rule; }

		//DollarTextExpression
		public RuleCall getDollarTextExpressionParserRuleCall() { return cDollarTextExpressionParserRuleCall; }
	}

	public class DollarTextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DollarTextExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVariableTextExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cVerbatimTELeadingAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTextAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTextDQT_DOLLARParserRuleCall_1_1_0 = (RuleCall)cTextAssignment_1_1.eContents().get(0);
		private final Assignment cTrailingAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTrailingTextExpressionParserRuleCall_1_2_0 = (RuleCall)cTrailingAssignment_1_2.eContents().get(0);
		
		//DollarTextExpression returns pp::TextExpression hidden():
		//	VariableTextExpression ({pp::VerbatimTE.leading=current} text=DQT_DOLLAR trailing=TextExpression?)*;
		public ParserRule getRule() { return rule; }

		//VariableTextExpression ({pp::VerbatimTE.leading=current} text=DQT_DOLLAR trailing=TextExpression?)*
		public Group getGroup() { return cGroup; }

		//VariableTextExpression
		public RuleCall getVariableTextExpressionParserRuleCall_0() { return cVariableTextExpressionParserRuleCall_0; }

		//({pp::VerbatimTE.leading=current} text=DQT_DOLLAR trailing=TextExpression?)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::VerbatimTE.leading=current}
		public Action getVerbatimTELeadingAction_1_0() { return cVerbatimTELeadingAction_1_0; }

		//text=DQT_DOLLAR
		public Assignment getTextAssignment_1_1() { return cTextAssignment_1_1; }

		//DQT_DOLLAR
		public RuleCall getTextDQT_DOLLARParserRuleCall_1_1_0() { return cTextDQT_DOLLARParserRuleCall_1_1_0; }

		//trailing=TextExpression?
		public Assignment getTrailingAssignment_1_2() { return cTrailingAssignment_1_2; }

		//TextExpression
		public RuleCall getTrailingTextExpressionParserRuleCall_1_2_0() { return cTrailingTextExpressionParserRuleCall_1_2_0; }
	}

	public class VariableTextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableTextExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionTextExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cVariableTELeadingAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cVarNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarNameDollarVariableParserRuleCall_1_1_0 = (RuleCall)cVarNameAssignment_1_1.eContents().get(0);
		private final Assignment cTrailingAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTrailingTextExpressionParserRuleCall_1_2_0 = (RuleCall)cTrailingAssignment_1_2.eContents().get(0);
		
		//VariableTextExpression returns pp::TextExpression hidden():
		//	ExpressionTextExpression ({pp::VariableTE.leading=current} varName=dollarVariable trailing=TextExpression?)*;
		public ParserRule getRule() { return rule; }

		//ExpressionTextExpression ({pp::VariableTE.leading=current} varName=dollarVariable trailing=TextExpression?)*
		public Group getGroup() { return cGroup; }

		//ExpressionTextExpression
		public RuleCall getExpressionTextExpressionParserRuleCall_0() { return cExpressionTextExpressionParserRuleCall_0; }

		//({pp::VariableTE.leading=current} varName=dollarVariable trailing=TextExpression?)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::VariableTE.leading=current}
		public Action getVariableTELeadingAction_1_0() { return cVariableTELeadingAction_1_0; }

		//varName=dollarVariable
		public Assignment getVarNameAssignment_1_1() { return cVarNameAssignment_1_1; }

		//dollarVariable
		public RuleCall getVarNameDollarVariableParserRuleCall_1_1_0() { return cVarNameDollarVariableParserRuleCall_1_1_0; }

		//trailing=TextExpression?
		public Assignment getTrailingAssignment_1_2() { return cTrailingAssignment_1_2; }

		//TextExpression
		public RuleCall getTrailingTextExpressionParserRuleCall_1_2_0() { return cTrailingTextExpressionParserRuleCall_1_2_0; }
	}

	public class ExpressionTextExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionTextExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cStringPartParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionTELeadingAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cDollarSignLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionExpressionWithHiddenParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cTrailingAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cTrailingTextExpressionParserRuleCall_1_4_0 = (RuleCall)cTrailingAssignment_1_4.eContents().get(0);
		
		//ExpressionTextExpression returns pp::TextExpression hidden(): // allow comments between ${ and }
		//// validate expression is not null == warning
		//	StringPart ({pp::ExpressionTE.leading=current} "${" expression=ExpressionWithHidden "}" trailing=TextExpression?)*;
		public ParserRule getRule() { return rule; }

		//// allow comments between ${ and }
		//// validate expression is not null == warning
		//StringPart ({pp::ExpressionTE.leading=current} "${" expression=ExpressionWithHidden "}" trailing=TextExpression?)*
		public Group getGroup() { return cGroup; }

		//// allow comments between ${ and }
		//// validate expression is not null == warning
		//StringPart
		public RuleCall getStringPartParserRuleCall_0() { return cStringPartParserRuleCall_0; }

		//({pp::ExpressionTE.leading=current} "${" expression=ExpressionWithHidden "}" trailing=TextExpression?)*
		public Group getGroup_1() { return cGroup_1; }

		//{pp::ExpressionTE.leading=current}
		public Action getExpressionTELeadingAction_1_0() { return cExpressionTELeadingAction_1_0; }

		//"${"
		public Keyword getDollarSignLeftCurlyBracketKeyword_1_1() { return cDollarSignLeftCurlyBracketKeyword_1_1; }

		//expression=ExpressionWithHidden
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }

		//ExpressionWithHidden
		public RuleCall getExpressionExpressionWithHiddenParserRuleCall_1_2_0() { return cExpressionExpressionWithHiddenParserRuleCall_1_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }

		//trailing=TextExpression?
		public Assignment getTrailingAssignment_1_4() { return cTrailingAssignment_1_4; }

		//TextExpression
		public RuleCall getTrailingTextExpressionParserRuleCall_1_4_0() { return cTrailingTextExpressionParserRuleCall_1_4_0; }
	}

	public class ExpressionWithHiddenElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionWithHidden");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParenthesisedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//// Consumation without creation is ok, if made optional where it is assigned, it is not possible to
		//// insert WS and comments into ExpressioNTextExpression.
		//ExpressionWithHidden returns pp::Expression hidden(WS, SL_COMMENT, ML_COMMENT):
		//	{pp::ParenthesisedExpression} expr=Expression?;
		public ParserRule getRule() { return rule; }

		//{pp::ParenthesisedExpression} expr=Expression?
		public Group getGroup() { return cGroup; }

		//{pp::ParenthesisedExpression}
		public Action getParenthesisedExpressionAction_0() { return cParenthesisedExpressionAction_0; }

		//expr=Expression?
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }
	}

	public class StringPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVerbatimTEAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextDoubleStringCharactersParserRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//StringPart returns pp::TextExpression hidden():
		//	{pp::VerbatimTE} text=doubleStringCharacters?;
		public ParserRule getRule() { return rule; }

		//{pp::VerbatimTE} text=doubleStringCharacters?
		public Group getGroup() { return cGroup; }

		//{pp::VerbatimTE}
		public Action getVerbatimTEAction_0() { return cVerbatimTEAction_0; }

		//text=doubleStringCharacters?
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }

		//doubleStringCharacters
		public RuleCall getTextDoubleStringCharactersParserRuleCall_1_0() { return cTextDoubleStringCharactersParserRuleCall_1_0; }
	}

	public class UnquotedStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnquotedString");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnquotedStringAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDollarSignLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//UnquotedString returns pp::Expression: // allow comments between ${ and }
		//// validate that Expression is not empty == warning
		//	{pp::UnquotedString} "${" expression=Expression? "}";
		public ParserRule getRule() { return rule; }

		//// allow comments between ${ and }
		//// validate that Expression is not empty == warning
		//{pp::UnquotedString} "${" expression=Expression? "}"
		public Group getGroup() { return cGroup; }

		//// allow comments between ${ and }
		//// validate that Expression is not empty == warning
		//{pp::UnquotedString}
		public Action getUnquotedStringAction_0() { return cUnquotedStringAction_0; }

		//"${"
		public Keyword getDollarSignLeftCurlyBracketKeyword_1() { return cDollarSignLeftCurlyBracketKeyword_1; }

		//expression=Expression?
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class SqTextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "sqText");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cSingleStringCharactersParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Has data conversion that strips leading/trailing single quotes
		//sqText returns ecore::EString hidden():
		//	"\'" singleStringCharacters? "\'";
		public ParserRule getRule() { return rule; }

		//"\'" singleStringCharacters? "\'"
		public Group getGroup() { return cGroup; }

		//"\'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }

		//singleStringCharacters?
		public RuleCall getSingleStringCharactersParserRuleCall_1() { return cSingleStringCharactersParserRuleCall_1; }

		//"\'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}

	public class LiteralRegexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralRegex");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueREGULAR_EXPRESSIONTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// Has validation rule that checks regex validity	
		//LiteralRegex returns pp::LiteralRegex:
		//	value=REGULAR_EXPRESSION;
		public ParserRule getRule() { return rule; }

		//value=REGULAR_EXPRESSION
		public Assignment getValueAssignment() { return cValueAssignment; }

		//REGULAR_EXPRESSION
		public RuleCall getValueREGULAR_EXPRESSIONTerminalRuleCall_0() { return cValueREGULAR_EXPRESSIONTerminalRuleCall_0; }
	}

	public class LiteralNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralName");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueUnionNameOrReferenceParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// VALIDATION: checks that the name is a NAME (and not a reference).
		//LiteralName returns pp::LiteralName:
		//	value=unionNameOrReference;
		public ParserRule getRule() { return rule; }

		//value=unionNameOrReference
		public Assignment getValueAssignment() { return cValueAssignment; }

		//unionNameOrReference
		public RuleCall getValueUnionNameOrReferenceParserRuleCall_0() { return cValueUnionNameOrReferenceParserRuleCall_0; }
	}

	public class VariableExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableExpression");
		private final Assignment cVarNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVarNameDollarVariableParserRuleCall_0 = (RuleCall)cVarNameAssignment.eContents().get(0);
		
		//VariableExpression returns pp::VariableExpression:
		//	varName=dollarVariable;
		public ParserRule getRule() { return rule; }

		//varName=dollarVariable
		public Assignment getVarNameAssignment() { return cVarNameAssignment; }

		//dollarVariable
		public RuleCall getVarNameDollarVariableParserRuleCall_0() { return cVarNameDollarVariableParserRuleCall_0; }
	}

	public class DollarVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dollarVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cKeywordParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//dollarVariable hidden():
		//	"$" (variable | keyword);
		public ParserRule getRule() { return rule; }

		//"$" (variable | keyword)
		public Group getGroup() { return cGroup; }

		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }

		//variable | keyword
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//variable
		public RuleCall getVariableParserRuleCall_1_0() { return cVariableParserRuleCall_1_0; }

		//keyword
		public RuleCall getKeywordParserRuleCall_1_1() { return cKeywordParserRuleCall_1_1; }
	}

	public class KeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "keyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCaseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cClassKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDefaultKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDefineKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cElseKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cElsifKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cInKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cInheritsKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cImportKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cNodeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cOrKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cUndefKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cTrueKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cFalseKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cIfKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		
		//keyword:
		//	"and" | "case" | "class" | "default" | "define" | "else" | "elsif" | "in" | "inherits" | "import" | "node" | "or" |
		//	"undef" | "true" | "false" | "if";
		public ParserRule getRule() { return rule; }

		//"and" | "case" | "class" | "default" | "define" | "else" | "elsif" | "in" | "inherits" | "import" | "node" | "or" |
		//"undef" | "true" | "false" | "if"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"and"
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }

		//"case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//"class"
		public Keyword getClassKeyword_2() { return cClassKeyword_2; }

		//"default"
		public Keyword getDefaultKeyword_3() { return cDefaultKeyword_3; }

		//"define"
		public Keyword getDefineKeyword_4() { return cDefineKeyword_4; }

		//"else"
		public Keyword getElseKeyword_5() { return cElseKeyword_5; }

		//"elsif"
		public Keyword getElsifKeyword_6() { return cElsifKeyword_6; }

		//"in"
		public Keyword getInKeyword_7() { return cInKeyword_7; }

		//"inherits"
		public Keyword getInheritsKeyword_8() { return cInheritsKeyword_8; }

		//"import"
		public Keyword getImportKeyword_9() { return cImportKeyword_9; }

		//"node"
		public Keyword getNodeKeyword_10() { return cNodeKeyword_10; }

		//"or"
		public Keyword getOrKeyword_11() { return cOrKeyword_11; }

		//"undef"
		public Keyword getUndefKeyword_12() { return cUndefKeyword_12; }

		//"true"
		public Keyword getTrueKeyword_13() { return cTrueKeyword_13; }

		//"false"
		public Keyword getFalseKeyword_14() { return cFalseKeyword_14; }

		//"if"
		public Keyword getIfKeyword_15() { return cIfKeyword_15; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "variable");
		private final RuleCall cWORD_CHARSTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// a puppet grammar glitch allows '::' any number of times (\w*::)*\w+. Validation checks correctness.
		//variable hidden():
		//	WORD_CHARS;
		public ParserRule getRule() { return rule; }

		//WORD_CHARS
		public RuleCall getWORD_CHARSTerminalRuleCall() { return cWORD_CHARSTerminalRuleCall; }
	}

	public class UnionNameOrReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unionNameOrReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWORD_CHARSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDefaultKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//// captures names and references, complicated by the fact that a keyword may be part of the name
		//// if the name contains '::' - for more info see the PPLexer
		//unionNameOrReference hidden():
		//	WORD_CHARS | "class" | "default";
		public ParserRule getRule() { return rule; }

		//WORD_CHARS | "class" | "default"
		public Alternatives getAlternatives() { return cAlternatives; }

		//WORD_CHARS
		public RuleCall getWORD_CHARSTerminalRuleCall_0() { return cWORD_CHARSTerminalRuleCall_0; }

		//"class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }

		//"default"
		public Keyword getDefaultKeyword_2() { return cDefaultKeyword_2; }
	}

	public class DoubleStringCharactersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "doubleStringCharacters");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWORD_CHARSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cANY_OTHERTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Keyword cReverseSolidusQuotationMarkKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cReverseSolidusApostropheKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cReverseSolidusDollarSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cReverseSolidusDollarSignLeftCurlyBracketKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cReverseSolidusReverseSolidusKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		
		//// special rules in lexer will deliver everything as one of these when in a string
		//doubleStringCharacters hidden():
		//	(WORD_CHARS | ANY_OTHER | WS | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+;
		public ParserRule getRule() { return rule; }

		//(WORD_CHARS | ANY_OTHER | WS | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+
		public Alternatives getAlternatives() { return cAlternatives; }

		//WORD_CHARS
		public RuleCall getWORD_CHARSTerminalRuleCall_0() { return cWORD_CHARSTerminalRuleCall_0; }

		//ANY_OTHER
		public RuleCall getANY_OTHERTerminalRuleCall_1() { return cANY_OTHERTerminalRuleCall_1; }

		//WS
		public RuleCall getWSTerminalRuleCall_2() { return cWSTerminalRuleCall_2; }

		//"\\\""
		public Keyword getReverseSolidusQuotationMarkKeyword_3() { return cReverseSolidusQuotationMarkKeyword_3; }

		//"\\\'"
		public Keyword getReverseSolidusApostropheKeyword_4() { return cReverseSolidusApostropheKeyword_4; }

		//"\\$"
		public Keyword getReverseSolidusDollarSignKeyword_5() { return cReverseSolidusDollarSignKeyword_5; }

		//"\\${"
		public Keyword getReverseSolidusDollarSignLeftCurlyBracketKeyword_6() { return cReverseSolidusDollarSignLeftCurlyBracketKeyword_6; }

		//"\\\\"
		public Keyword getReverseSolidusReverseSolidusKeyword_7() { return cReverseSolidusReverseSolidusKeyword_7; }
	}

	public class SingleStringCharactersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "singleStringCharacters");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWORD_CHARSTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cANY_OTHERTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWSTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Keyword cDollarSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDollarSignLeftCurlyBracketKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cReverseSolidusQuotationMarkKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cReverseSolidusApostropheKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cReverseSolidusDollarSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cReverseSolidusDollarSignLeftCurlyBracketKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cReverseSolidusReverseSolidusKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		
		//// special rules in lexer will deliver everything as one of these when in a string
		//singleStringCharacters hidden():
		//	(WORD_CHARS | ANY_OTHER | WS | // terminates dq-, but not sq- string
		//	"$" | // terminates dq-, but not sq- string
		//	"${" | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+;
		public ParserRule getRule() { return rule; }

		//(WORD_CHARS | ANY_OTHER | WS | // terminates dq-, but not sq- string
		//"$" | // terminates dq-, but not sq- string
		//"${" | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+
		public Alternatives getAlternatives() { return cAlternatives; }

		//WORD_CHARS
		public RuleCall getWORD_CHARSTerminalRuleCall_0() { return cWORD_CHARSTerminalRuleCall_0; }

		//ANY_OTHER
		public RuleCall getANY_OTHERTerminalRuleCall_1() { return cANY_OTHERTerminalRuleCall_1; }

		//WS
		public RuleCall getWSTerminalRuleCall_2() { return cWSTerminalRuleCall_2; }

		//// terminates dq-, but not sq- string
		//"$"
		public Keyword getDollarSignKeyword_3() { return cDollarSignKeyword_3; }

		//// terminates dq-, but not sq- string
		//"${"
		public Keyword getDollarSignLeftCurlyBracketKeyword_4() { return cDollarSignLeftCurlyBracketKeyword_4; }

		//"\\\""
		public Keyword getReverseSolidusQuotationMarkKeyword_5() { return cReverseSolidusQuotationMarkKeyword_5; }

		//"\\\'"
		public Keyword getReverseSolidusApostropheKeyword_6() { return cReverseSolidusApostropheKeyword_6; }

		//"\\$"
		public Keyword getReverseSolidusDollarSignKeyword_7() { return cReverseSolidusDollarSignKeyword_7; }

		//"\\${"
		public Keyword getReverseSolidusDollarSignLeftCurlyBracketKeyword_8() { return cReverseSolidusDollarSignLeftCurlyBracketKeyword_8; }

		//"\\\\"
		public Keyword getReverseSolidusReverseSolidusKeyword_9() { return cReverseSolidusReverseSolidusKeyword_9; }
	}
	
	
	private PuppetManifestElements pPuppetManifest;
	private ExpressionElements pExpression;
	private ExpressionListElements pExpressionList;
	private EdgeOperatorElements pEdgeOperator;
	private RelationshipExpressionElements pRelationshipExpression;
	private ResourceExpressionElements pResourceExpression;
	private ResourceBodyElements pResourceBody;
	private AttributeOperationElements pAttributeOperation;
	private AttributeOperationsElements pAttributeOperations;
	private EndCommaElements pEndComma;
	private AssignmentExpressionElements pAssignmentExpression;
	private AppendExpressionElements pAppendExpression;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private RelationalOperatorElements pRelationalOperator;
	private RelationalExpressionElements pRelationalExpression;
	private EqualityOperatorElements pEqualityOperator;
	private EqualityExpressionElements pEqualityExpression;
	private ShiftOperatorElements pShiftOperator;
	private ShiftExpressionElements pShiftExpression;
	private AdditiveOperatorElements pAdditiveOperator;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplicativeOperatorElements pMultiplicativeOperator;
	private MultiplicativeExpressionElements pMultiplicativeExpression;
	private MatchingOperatorElements pMatchingOperator;
	private MatchingExpressionElements pMatchingExpression;
	private InExpressionElements pInExpression;
	private UnaryOrHigherExpressionElements pUnaryOrHigherExpression;
	private UnaryMinusExpressionElements pUnaryMinusExpression;
	private NotExpressionElements pNotExpression;
	private CollectExpressionElements pCollectExpression;
	private CollectQueryElements pCollectQuery;
	private VirtualCollectQueryElements pVirtualCollectQuery;
	private ExportedCollectQueryElements pExportedCollectQuery;
	private SelectorExpressionElements pSelectorExpression;
	private SelectorEntryElements pSelectorEntry;
	private AtExpressionElements pAtExpression;
	private FunctionCallElements pFunctionCall;
	private PrimaryExpressionElements pPrimaryExpression;
	private NodeDefinitionElements pNodeDefinition;
	private HostReferenceElements pHostReference;
	private HostClassDefinitionElements pHostClassDefinition;
	private ParentNameElements pParentName;
	private DefinitionElements pDefinition;
	private DefinitionArgumentListElements pDefinitionArgumentList;
	private DefinitionArgumentElements pDefinitionArgument;
	private CaseExpressionElements pCaseExpression;
	private CaseElements pCase;
	private IfExpressionElements pIfExpression;
	private ElseExpressionElements pElseExpression;
	private ElseIfExpressionElements pElseIfExpression;
	private LiteralExpressionElements pLiteralExpression;
	private LiteralNameOrReferenceElements pLiteralNameOrReference;
	private UNION_VARIABLE_OR_NAMEElements pUNION_VARIABLE_OR_NAME;
	private ParenthisedExpressionElements pParenthisedExpression;
	private VirtualNameOrReferenceElements pVirtualNameOrReference;
	private ATBooleanElements pATBoolean;
	private ImportExpressionElements pImportExpression;
	private LiteralListElements pLiteralList;
	private LiteralHashElements pLiteralHash;
	private HashEntryElements pHashEntry;
	private LiteralNameOrStringElements pLiteralNameOrString;
	private BooleanValueElements pBooleanValue;
	private LiteralBooleanElements pLiteralBoolean;
	private LiteralDefaultElements pLiteralDefault;
	private LiteralUndefElements pLiteralUndef;
	private StringExpressionElements pStringExpression;
	private QuotedStringElements pQuotedString;
	private SingleQuotedStringElements pSingleQuotedString;
	private DQT_DOLLARElements pDQT_DOLLAR;
	private DoubleQuotedStringElements pDoubleQuotedString;
	private TextExpressionElements pTextExpression;
	private DollarTextExpressionElements pDollarTextExpression;
	private VariableTextExpressionElements pVariableTextExpression;
	private ExpressionTextExpressionElements pExpressionTextExpression;
	private ExpressionWithHiddenElements pExpressionWithHidden;
	private StringPartElements pStringPart;
	private UnquotedStringElements pUnquotedString;
	private SqTextElements pSqText;
	private LiteralRegexElements pLiteralRegex;
	private LiteralNameElements pLiteralName;
	private VariableExpressionElements pVariableExpression;
	private DollarVariableElements pDollarVariable;
	private KeywordElements pKeyword;
	private VariableElements pVariable;
	private UnionNameOrReferenceElements pUnionNameOrReference;
	private DoubleStringCharactersElements pDoubleStringCharacters;
	private SingleStringCharactersElements pSingleStringCharacters;
	private TerminalRule tML_COMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tWORD_CHARS;
	private TerminalRule tREGULAR_EXPRESSION;
	private TerminalRule tRE_BODY;
	private TerminalRule tRE_FIRST_CHAR;
	private TerminalRule tRE_FOLLOW_CHAR;
	private TerminalRule tRE_BACKSLASH_SEQUENCE;
	private TerminalRule tRE_FLAGS;
	private TerminalRule tANY_OTHER;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public PPGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//PuppetManifest returns pp::PuppetManifest:
	//	{pp::PuppetManifest} statements+=ExpressionList*;
	public PuppetManifestElements getPuppetManifestAccess() {
		return (pPuppetManifest != null) ? pPuppetManifest : (pPuppetManifest = new PuppetManifestElements());
	}
	
	public ParserRule getPuppetManifestRule() {
		return getPuppetManifestAccess().getRule();
	}

	//// -- EXPRESSION
	//// (Refers to the expression with the lowest precedence)
	//// Should be used by expressions that allow a single Expression
	//Expression returns pp::Expression:
	//	RelationshipExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// --EXPRESSION LIST
	//// Should be used by expressions that allow a sequence of expressions (as such
	//// a sequence can include non-parenthesized function calls (which are detected after
	//// parsing)
	//ExpressionList returns pp::Expression:
	//	RelationshipExpression ({pp::ExprList.expressions+=current} "," expressions+=RelationshipExpression (","
	//	expressions+=RelationshipExpression)*)?;
	public ExpressionListElements getExpressionListAccess() {
		return (pExpressionList != null) ? pExpressionList : (pExpressionList = new ExpressionListElements());
	}
	
	public ParserRule getExpressionListRule() {
		return getExpressionListAccess().getRule();
	}

	//// LOWEST PRECEDENCE
	////  left  relationship
	////  left  assignment
	////  left  OR
	////  left  AND
	////  left  Relational: GREATEREQUAL GREATERTHAN LESSTHAN LESSEQUAL
	////  left  Equality: NOTEQUAL ISEQUAL
	////  left  Shift: LSHIFT RSHIFT
	////  left  Additive: '-' PLUS
	////  left  Multiplicative: TIMES DIV
	////  left  Matching: IN MATCH NOMATCH
	////  nonassoc UMINUS
	////  right NOT
	////  'primary'
	//// HIGHEST
	//// Relationship
	//// Note that RelationshipExpression has lowest precedence since it has an operator
	//// '<-' that otherwise clashes with LT UnaryMinus
	////
	//// VALIDATION checks that left and right are one of: 
	//// - ResourceExpression (but not a ResourceOverride, or virtual resource)
	//// - ResourceReference
	//// - CollectExpression
	//EdgeOperator:
	//	"->" | "<-" | "~>" | "<~";
	public EdgeOperatorElements getEdgeOperatorAccess() {
		return (pEdgeOperator != null) ? pEdgeOperator : (pEdgeOperator = new EdgeOperatorElements());
	}
	
	public ParserRule getEdgeOperatorRule() {
		return getEdgeOperatorAccess().getRule();
	}

	//RelationshipExpression returns pp::Expression:
	//	ResourceExpression ({pp::RelationshipExpression.leftExpr=current} opName=EdgeOperator rightExpr=ResourceExpression)*;
	public RelationshipExpressionElements getRelationshipExpressionAccess() {
		return (pRelationshipExpression != null) ? pRelationshipExpression : (pRelationshipExpression = new RelationshipExpressionElements());
	}
	
	public ParserRule getRelationshipExpressionRule() {
		return getRelationshipExpressionAccess().getRule();
	}

	//// -- ResourceExpression 
	//// handles:
	//// - resource definition 'name {'
	//// - defaults for resource definitions  'Name {'
	//// - resource overrides 'expr [exprlist] {'
	//// - virtual and exported resources @name {, and @@name {
	//// The parser makes no distinction between these and allows nested expresions compatible with all three
	//// VALIDATION checks:
	//// - if resourceClass != CLASS_REF, then ResourceBodies must have a name
	//// - if resourceClass == CLASS_REF or AtExpression, 
	////		then only one ResourceBody is allowed, and ResourceBody can not have a name
	//// - if resourceExpr = AtExpression the ResourceBody's attribute list may contain additions, otherwise not			
	////
	//ResourceExpression returns pp::Expression:
	//	AssignmentExpression ({pp::ResourceExpression.resourceExpr=current} "{" (resourceData+=ResourceBody (";"
	//	resourceData+=ResourceBody)* ";"?)? "}")?;
	public ResourceExpressionElements getResourceExpressionAccess() {
		return (pResourceExpression != null) ? pResourceExpression : (pResourceExpression = new ResourceExpressionElements());
	}
	
	public ParserRule getResourceExpressionRule() {
		return getResourceExpressionAccess().getRule();
	}

	//// Note: allows all AttributeOperation subtypes but this depends on the parent's type
	//// VALIDATION checks allowed types	
	//ResourceBody returns pp::ResourceBody:
	//	nameExpr=Expression ":" attributes=AttributeOperations? | attributes=AttributeOperations;
	public ResourceBodyElements getResourceBodyAccess() {
		return (pResourceBody != null) ? pResourceBody : (pResourceBody = new ResourceBodyElements());
	}
	
	public ParserRule getResourceBodyRule() {
		return getResourceBodyAccess().getRule();
	}

	////// VALIDATION: checks that key is a NAME
	////AttributeDefinition returns pp::AttributeDefinition
	////	: unionNameOrReference ({pp::AttributeDefinition.key = current} '=>' value = Expression) 
	//////	:  key = unionNameOrReference  '=>'  value = Expression 
	////	;
	////// VALIDATION: checks that key is a NAME
	////AttributeAddition returns pp::AttributeAddition
	////	:  key = unionNameOrReference  '+>'  value = Expression
	////	;
	//// VALIDATION: key is a NAME, op is supported and Expression is not null
	//AttributeOperation returns pp::AttributeOperation:
	//	=> key=unionNameOrReference (op=("=>" | "+>") value=Expression)?;
	public AttributeOperationElements getAttributeOperationAccess() {
		return (pAttributeOperation != null) ? pAttributeOperation : (pAttributeOperation = new AttributeOperationElements());
	}
	
	public ParserRule getAttributeOperationRule() {
		return getAttributeOperationAccess().getRule();
	}

	////AttributeOperation returns pp::AttributeOperation
	////	: AttributeDefinition
	////	| AttributeAddition
	////	;
	//// VALIDATION: checks that there are ',' between operations
	//// NOTE: if ','	is mandatory in grammar, backtracking will think statement is a different (faulty)
	//// statement.
	//AttributeOperations returns pp::AttributeOperations:
	//	attributes+=AttributeOperation ("," attributes+=AttributeOperation | attributes+=AttributeOperation)* ","?;
	public AttributeOperationsElements getAttributeOperationsAccess() {
		return (pAttributeOperations != null) ? pAttributeOperations : (pAttributeOperations = new AttributeOperationsElements());
	}
	
	public ParserRule getAttributeOperationsRule() {
		return getAttributeOperationsAccess().getRule();
	}

	//// NOTE: This construct is required due to an Xtext bug, it would be preferred to state (',' )? directly
	//// in rules using endComma as this makes formatting work ok. The construct below will hide the  and
	//// formatting needs to be aware of the  in an endComma.
	//endComma:
	//	",";
	public EndCommaElements getEndCommaAccess() {
		return (pEndComma != null) ? pEndComma : (pEndComma = new EndCommaElements());
	}
	
	public ParserRule getEndCommaRule() {
		return getEndCommaAccess().getRule();
	}

	//// VALIDATION checks leftExpr must be '@' or Variable
	//AssignmentExpression returns pp::Expression:
	//	AppendExpression ({pp::AssignmentExpression.leftExpr=current} "=" rightExpr=AppendExpression)?;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return (pAssignmentExpression != null) ? pAssignmentExpression : (pAssignmentExpression = new AssignmentExpressionElements());
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//// VALIDATION checks leftExpr must be Variable (does not seem to allow append to at - e.g. a[1] +=)
	//AppendExpression returns pp::Expression:
	//	OrExpression ({pp::AppendExpression.leftExpr=current} "+=" rightExpr=OrExpression)?;
	public AppendExpressionElements getAppendExpressionAccess() {
		return (pAppendExpression != null) ? pAppendExpression : (pAppendExpression = new AppendExpressionElements());
	}
	
	public ParserRule getAppendExpressionRule() {
		return getAppendExpressionAccess().getRule();
	}

	//OrExpression returns pp::Expression:
	//	AndExpression ({pp::OrExpression.leftExpr=current} "or" rightExpr=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns pp::Expression:
	//	RelationalExpression ({pp::AndExpression.leftExpr=current} "and" rightExpr=RelationalExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//RelationalOperator:
	//	">=" | "<=" | ">" | "<";
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return (pRelationalOperator != null) ? pRelationalOperator : (pRelationalOperator = new RelationalOperatorElements());
	}
	
	public ParserRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//RelationalExpression returns pp::Expression:
	//	EqualityExpression ({pp::RelationalExpression.leftExpr=current} opName=RelationalOperator
	//	rightExpr=EqualityExpression)*;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//EqualityOperator:
	//	"==" | "!=";
	public EqualityOperatorElements getEqualityOperatorAccess() {
		return (pEqualityOperator != null) ? pEqualityOperator : (pEqualityOperator = new EqualityOperatorElements());
	}
	
	public ParserRule getEqualityOperatorRule() {
		return getEqualityOperatorAccess().getRule();
	}

	//EqualityExpression returns pp::Expression:
	//	ShiftExpression ({pp::EqualityExpression.leftExpr=current} opName=EqualityOperator rightExpr=ShiftExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return (pEqualityExpression != null) ? pEqualityExpression : (pEqualityExpression = new EqualityExpressionElements());
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	//ShiftOperator:
	//	"<<" | ">>";
	public ShiftOperatorElements getShiftOperatorAccess() {
		return (pShiftOperator != null) ? pShiftOperator : (pShiftOperator = new ShiftOperatorElements());
	}
	
	public ParserRule getShiftOperatorRule() {
		return getShiftOperatorAccess().getRule();
	}

	//ShiftExpression returns pp::Expression:
	//	AdditiveExpression ({pp::ShiftExpression.leftExpr=current} opName=ShiftOperator rightExpr=AdditiveExpression)*;
	public ShiftExpressionElements getShiftExpressionAccess() {
		return (pShiftExpression != null) ? pShiftExpression : (pShiftExpression = new ShiftExpressionElements());
	}
	
	public ParserRule getShiftExpressionRule() {
		return getShiftExpressionAccess().getRule();
	}

	//AdditiveOperator:
	//	"+" | "-";
	public AdditiveOperatorElements getAdditiveOperatorAccess() {
		return (pAdditiveOperator != null) ? pAdditiveOperator : (pAdditiveOperator = new AdditiveOperatorElements());
	}
	
	public ParserRule getAdditiveOperatorRule() {
		return getAdditiveOperatorAccess().getRule();
	}

	//AdditiveExpression returns pp::Expression:
	//	MultiplicativeExpression ({pp::AdditiveExpression.leftExpr=current} opName=AdditiveOperator
	//	rightExpr=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//MultiplicativeOperator:
	//	"*" | "/";
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return (pMultiplicativeOperator != null) ? pMultiplicativeOperator : (pMultiplicativeOperator = new MultiplicativeOperatorElements());
	}
	
	public ParserRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}

	//MultiplicativeExpression returns pp::Expression:
	//	MatchingExpression ({pp::MultiplicativeExpression.leftExpr=current} opName=MultiplicativeOperator
	//	rightExpr=MatchingExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return (pMultiplicativeExpression != null) ? pMultiplicativeExpression : (pMultiplicativeExpression = new MultiplicativeExpressionElements());
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//// VALIDATION checks regex rhs
	//MatchingOperator:
	//	"=~" | "!~";
	public MatchingOperatorElements getMatchingOperatorAccess() {
		return (pMatchingOperator != null) ? pMatchingOperator : (pMatchingOperator = new MatchingOperatorElements());
	}
	
	public ParserRule getMatchingOperatorRule() {
		return getMatchingOperatorAccess().getRule();
	}

	//MatchingExpression returns pp::Expression:
	//	InExpression ({pp::MatchingExpression.leftExpr=current} opName=MatchingOperator rightExpr=LiteralRegex)*;
	public MatchingExpressionElements getMatchingExpressionAccess() {
		return (pMatchingExpression != null) ? pMatchingExpression : (pMatchingExpression = new MatchingExpressionElements());
	}
	
	public ParserRule getMatchingExpressionRule() {
		return getMatchingExpressionAccess().getRule();
	}

	//InExpression returns pp::Expression:
	//	UnaryOrHigherExpression ({pp::InExpression.leftExpr=current} opName="in" rightExpr=UnaryOrHigherExpression)*;
	public InExpressionElements getInExpressionAccess() {
		return (pInExpression != null) ? pInExpression : (pInExpression = new InExpressionElements());
	}
	
	public ParserRule getInExpressionRule() {
		return getInExpressionAccess().getRule();
	}

	//UnaryOrHigherExpression returns pp::Expression:
	//	UnaryMinusExpression | NotExpression | CollectExpression;
	public UnaryOrHigherExpressionElements getUnaryOrHigherExpressionAccess() {
		return (pUnaryOrHigherExpression != null) ? pUnaryOrHigherExpression : (pUnaryOrHigherExpression = new UnaryOrHigherExpressionElements());
	}
	
	public ParserRule getUnaryOrHigherExpressionRule() {
		return getUnaryOrHigherExpressionAccess().getRule();
	}

	//UnaryMinusExpression returns pp::UnaryMinusExpression:
	//	"-" expr=CollectExpression;
	public UnaryMinusExpressionElements getUnaryMinusExpressionAccess() {
		return (pUnaryMinusExpression != null) ? pUnaryMinusExpression : (pUnaryMinusExpression = new UnaryMinusExpressionElements());
	}
	
	public ParserRule getUnaryMinusExpressionRule() {
		return getUnaryMinusExpressionAccess().getRule();
	}

	//NotExpression returns pp::UnaryNotExpression:
	//	"!" expr=CollectExpression;
	public NotExpressionElements getNotExpressionAccess() {
		return (pNotExpression != null) ? pNotExpression : (pNotExpression = new NotExpressionElements());
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// VALIDATION checks that CollectExpression classReference is a ClassReference, and that query expressions
	//// conform to a limit set of supported expressions.
	//CollectExpression returns pp::Expression:
	//	SelectorExpression ({pp::CollectExpression.classReference=current} query=CollectQuery ("{"
	//	attributes=AttributeOperations? "}")?)?;
	public CollectExpressionElements getCollectExpressionAccess() {
		return (pCollectExpression != null) ? pCollectExpression : (pCollectExpression = new CollectExpressionElements());
	}
	
	public ParserRule getCollectExpressionRule() {
		return getCollectExpressionAccess().getRule();
	}

	//// VALIDATION ensures that query only contains:
	////  - ('and' | 'or' | VariableExpression | LiteralName | '==' | '!=' | ParentesisesExpression )	
	//CollectQuery returns pp::ICollectQuery:
	//	VirtualCollectQuery | ExportedCollectQuery;
	public CollectQueryElements getCollectQueryAccess() {
		return (pCollectQuery != null) ? pCollectQuery : (pCollectQuery = new CollectQueryElements());
	}
	
	public ParserRule getCollectQueryRule() {
		return getCollectQueryAccess().getRule();
	}

	//VirtualCollectQuery returns pp::ICollectQuery:
	//	{pp::VirtualCollectQuery} "<|" expr=Expression? "|>";
	public VirtualCollectQueryElements getVirtualCollectQueryAccess() {
		return (pVirtualCollectQuery != null) ? pVirtualCollectQuery : (pVirtualCollectQuery = new VirtualCollectQueryElements());
	}
	
	public ParserRule getVirtualCollectQueryRule() {
		return getVirtualCollectQueryAccess().getRule();
	}

	//ExportedCollectQuery returns pp::ICollectQuery:
	//	{pp::ExportedCollectQuery} "<<|" expr=Expression? "|>>";
	public ExportedCollectQueryElements getExportedCollectQueryAccess() {
		return (pExportedCollectQuery != null) ? pExportedCollectQuery : (pExportedCollectQuery = new ExportedCollectQueryElements());
	}
	
	public ParserRule getExportedCollectQueryRule() {
		return getExportedCollectQueryAccess().getRule();
	}

	//SelectorExpression returns pp::Expression: // WAS: FunctionCall 
	//	AtExpression ({pp::SelectorExpression.leftExpr=current} "?" ("{" parameters+=SelectorEntry (","
	//	parameters+=SelectorEntry)* endComma? "}" | parameters+=SelectorEntry))?;
	public SelectorExpressionElements getSelectorExpressionAccess() {
		return (pSelectorExpression != null) ? pSelectorExpression : (pSelectorExpression = new SelectorExpressionElements());
	}
	
	public ParserRule getSelectorExpressionRule() {
		return getSelectorExpressionAccess().getRule();
	}

	//// VALIDATION  checks lhs is a valid selector left value
	//SelectorEntry returns pp::Expression:
	//	Expression ({pp::SelectorEntry.leftExpr=current} "=>" rightExpr=Expression)?;
	public SelectorEntryElements getSelectorEntryAccess() {
		return (pSelectorEntry != null) ? pSelectorEntry : (pSelectorEntry = new SelectorEntryElements());
	}
	
	public ParserRule getSelectorEntryRule() {
		return getSelectorEntryAccess().getRule();
	}

	//// Note: AtExpression serves dual purpose: ResourceReference and '#' access
	//// VALIDATION: checks 2 level nesting constraint on At a[x][y] is ok but not a[x][y][z] if bug compatible mode
	//// VALIDATION: checks At dual roles and validates accordingly (only single parameter for normal At) etc.	
	//AtExpression returns pp::Expression: // WAS: CollectExpression 
	//	FunctionCall ({pp::AtExpression.leftExpr=current} "[" (parameters+=Expression ("," parameters+=Expression)*)? "]")*;
	public AtExpressionElements getAtExpressionAccess() {
		return (pAtExpression != null) ? pAtExpression : (pAtExpression = new AtExpressionElements());
	}
	
	public ParserRule getAtExpressionRule() {
		return getAtExpressionAccess().getRule();
	}

	//// FunctionCall has different syntax restrictions depending on context
	//// - when used where only one expression can occur, parantheses are required around the arguments
	//// To solve this, the parser does NOT recognize func x as a function call, this is instead treated as
	//// a sequence of two expressions, a later step will need to determine if 'func' is a function, if so, how
	//// many arguments it is supposed to take, and then validate if the input is correct.
	////
	//// VALIDATION : functionExpr is a valid function name	
	//FunctionCall returns pp::Expression:
	//	PrimaryExpression ({pp::FunctionCall.leftExpr=current} "(" (parameters+=Expression ("," parameters+=Expression)*
	//	endComma?)? ")")?;
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//PrimaryExpression returns pp::Expression:
	//	IfExpression | CaseExpression | ImportExpression | Definition | HostClassDefinition | NodeDefinition |
	//	VirtualNameOrReference | LiteralExpression | VariableExpression | ParenthisedExpression;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//NodeDefinition returns pp::NodeDefinition:
	//	"node" hostNames+=HostReference ("," hostNames+=HostReference)* ("inherits" parentName=HostReference)? "{"
	//	statements+=ExpressionList* "}";
	public NodeDefinitionElements getNodeDefinitionAccess() {
		return (pNodeDefinition != null) ? pNodeDefinition : (pNodeDefinition = new NodeDefinitionElements());
	}
	
	public ParserRule getNodeDefinitionRule() {
		return getNodeDefinitionAccess().getRule();
	}

	//HostReference returns pp::Expression:
	//	StringExpression | LiteralRegex | LiteralDefault | LiteralNameOrReference;
	public HostReferenceElements getHostReferenceAccess() {
		return (pHostReference != null) ? pHostReference : (pHostReference = new HostReferenceElements());
	}
	
	public ParserRule getHostReferenceRule() {
		return getHostReferenceAccess().getRule();
	}

	//HostClassDefinition returns pp::HostClassDefinition:
	//	"class" className=unionNameOrReference arguments=DefinitionArgumentList? ("inherits" parent=ParentName)? "{"
	//	statements+=ExpressionList* "}";
	public HostClassDefinitionElements getHostClassDefinitionAccess() {
		return (pHostClassDefinition != null) ? pHostClassDefinition : (pHostClassDefinition = new HostClassDefinitionElements());
	}
	
	public ParserRule getHostClassDefinitionRule() {
		return getHostClassDefinitionAccess().getRule();
	}

	//ParentName returns pp::LiteralExpression:
	//	LiteralDefault | LiteralNameOrReference;
	public ParentNameElements getParentNameAccess() {
		return (pParentName != null) ? pParentName : (pParentName = new ParentNameElements());
	}
	
	public ParserRule getParentNameRule() {
		return getParentNameAccess().getRule();
	}

	//Definition returns pp::Definition:
	//	"define" className=unionNameOrReference arguments=DefinitionArgumentList? "{" statements+=ExpressionList* "}";
	public DefinitionElements getDefinitionAccess() {
		return (pDefinition != null) ? pDefinition : (pDefinition = new DefinitionElements());
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}

	//DefinitionArgumentList returns pp::DefinitionArgumentList:
	//	{pp::DefinitionArgumentList} "(" (arguments+=DefinitionArgument ("," arguments+=DefinitionArgument)*)? endComma? ")";
	public DefinitionArgumentListElements getDefinitionArgumentListAccess() {
		return (pDefinitionArgumentList != null) ? pDefinitionArgumentList : (pDefinitionArgumentList = new DefinitionArgumentListElements());
	}
	
	public ParserRule getDefinitionArgumentListRule() {
		return getDefinitionArgumentListAccess().getRule();
	}

	//// VALIDATION: Depracted warning if name does not start with $
	//// VALIDATION: Not all variations of SimplefiedVariableOrName are valid (with NS)
	//// VALIDATION: value expr is RVALUE
	//// 	
	//DefinitionArgument returns pp::DefinitionArgument:
	//	argName=UNION_VARIABLE_OR_NAME ((op="=" | op="=>") value=Expression)?;
	public DefinitionArgumentElements getDefinitionArgumentAccess() {
		return (pDefinitionArgument != null) ? pDefinitionArgument : (pDefinitionArgument = new DefinitionArgumentElements());
	}
	
	public ParserRule getDefinitionArgumentRule() {
		return getDefinitionArgumentAccess().getRule();
	}

	////-- CASE
	////
	//CaseExpression returns pp::CaseExpression:
	//	"case" switchExpr=Expression "{" cases+=Case* "}";
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	//Case returns pp::Case:
	//	values+=Expression ("," values+=Expression)* ":" "{" statements+=ExpressionList* "}";
	public CaseElements getCaseAccess() {
		return (pCase != null) ? pCase : (pCase = new CaseElements());
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	////-- IF 
	////
	//// VALIDATION: checks that the elseStatement is an Else of Elsif, and validate that Else or Elsif
	//// only appears as parented by If, Else or Elseif
	//IfExpression returns pp::IfExpression:
	//	"if" condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif" elseStatement=ElseIfExpression | "else"
	//	elseStatement=ElseExpression)?;
	public IfExpressionElements getIfExpressionAccess() {
		return (pIfExpression != null) ? pIfExpression : (pIfExpression = new IfExpressionElements());
	}
	
	public ParserRule getIfExpressionRule() {
		return getIfExpressionAccess().getRule();
	}

	//ElseExpression returns pp::Expression:
	//	{pp::ElseExpression} "{" statements+=ExpressionList* "}";
	public ElseExpressionElements getElseExpressionAccess() {
		return (pElseExpression != null) ? pElseExpression : (pElseExpression = new ElseExpressionElements());
	}
	
	public ParserRule getElseExpressionRule() {
		return getElseExpressionAccess().getRule();
	}

	//ElseIfExpression returns pp::Expression:
	//	{pp::ElseIfExpression} condExpr=Expression "{" thenStatements+=ExpressionList* "}" ("elsif"
	//	elseStatement=ElseIfExpression | "else" elseStatement=ElseExpression)?;
	public ElseIfExpressionElements getElseIfExpressionAccess() {
		return (pElseIfExpression != null) ? pElseIfExpression : (pElseIfExpression = new ElseIfExpressionElements());
	}
	
	public ParserRule getElseIfExpressionRule() {
		return getElseIfExpressionAccess().getRule();
	}

	//LiteralExpression returns pp::Expression:
	//	LiteralBoolean | LiteralUndef | LiteralDefault | LiteralList | LiteralHash | LiteralRegex | StringExpression |
	//	LiteralNameOrReference;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return (pLiteralExpression != null) ? pLiteralExpression : (pLiteralExpression = new LiteralExpressionElements());
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//LiteralNameOrReference returns pp::LiteralNameOrReference:
	//	value=unionNameOrReference;
	public LiteralNameOrReferenceElements getLiteralNameOrReferenceAccess() {
		return (pLiteralNameOrReference != null) ? pLiteralNameOrReference : (pLiteralNameOrReference = new LiteralNameOrReferenceElements());
	}
	
	public ParserRule getLiteralNameOrReferenceRule() {
		return getLiteralNameOrReferenceAccess().getRule();
	}

	//UNION_VARIABLE_OR_NAME:
	//	"$" (unionNameOrReference | keyword) | unionNameOrReference;
	public UNION_VARIABLE_OR_NAMEElements getUNION_VARIABLE_OR_NAMEAccess() {
		return (pUNION_VARIABLE_OR_NAME != null) ? pUNION_VARIABLE_OR_NAME : (pUNION_VARIABLE_OR_NAME = new UNION_VARIABLE_OR_NAMEElements());
	}
	
	public ParserRule getUNION_VARIABLE_OR_NAMERule() {
		return getUNION_VARIABLE_OR_NAMEAccess().getRule();
	}

	//// validate that expr is not empty	
	//ParenthisedExpression returns pp::ParenthesisedExpression:
	//	"(" {pp::ParenthesisedExpression} expr=Expression? ")";
	public ParenthisedExpressionElements getParenthisedExpressionAccess() {
		return (pParenthisedExpression != null) ? pParenthisedExpression : (pParenthisedExpression = new ParenthisedExpressionElements());
	}
	
	public ParserRule getParenthisedExpressionRule() {
		return getParenthisedExpressionAccess().getRule();
	}

	//VirtualNameOrReference returns pp::VirtualNameOrReference:
	//	"@" exported=ATBoolean? value=unionNameOrReference;
	public VirtualNameOrReferenceElements getVirtualNameOrReferenceAccess() {
		return (pVirtualNameOrReference != null) ? pVirtualNameOrReference : (pVirtualNameOrReference = new VirtualNameOrReferenceElements());
	}
	
	public ParserRule getVirtualNameOrReferenceRule() {
		return getVirtualNameOrReferenceAccess().getRule();
	}

	//// Kludge for a serialization issue using exported = '@'?
	//// Note: has value converter
	//ATBoolean returns ecore::EBoolean:
	//	"@";
	public ATBooleanElements getATBooleanAccess() {
		return (pATBoolean != null) ? pATBoolean : (pATBoolean = new ATBooleanElements());
	}
	
	public ParserRule getATBooleanRule() {
		return getATBooleanAccess().getRule();
	}

	//// VALIDATION: No interpolation takes place in DoubleQuotedStrings, a warning will be issued.
	//// VALIDATION: Checks that import has at least one thing to import	
	//ImportExpression returns pp::ImportExpression:
	//	{pp::ImportExpression} "import" (values+=QuotedString ("," values+=QuotedString)*)?;
	public ImportExpressionElements getImportExpressionAccess() {
		return (pImportExpression != null) ? pImportExpression : (pImportExpression = new ImportExpressionElements());
	}
	
	public ParserRule getImportExpressionRule() {
		return getImportExpressionAccess().getRule();
	}

	//LiteralList returns pp::LiteralList:
	//	{pp::LiteralList} "[" (elements+=Expression ("," elements+=Expression)*)? endComma? "]";
	public LiteralListElements getLiteralListAccess() {
		return (pLiteralList != null) ? pLiteralList : (pLiteralList = new LiteralListElements());
	}
	
	public ParserRule getLiteralListRule() {
		return getLiteralListAccess().getRule();
	}

	//LiteralHash returns pp::LiteralHash:
	//	{pp::LiteralHash} "{" (elements+=HashEntry ("," elements+=HashEntry)*)? endComma? "}";
	public LiteralHashElements getLiteralHashAccess() {
		return (pLiteralHash != null) ? pLiteralHash : (pLiteralHash = new LiteralHashElements());
	}
	
	public ParserRule getLiteralHashRule() {
		return getLiteralHashAccess().getRule();
	}

	//// Use LiteralNameOrString to get different literals (to preserve quotes) as opposed to just the token value.
	//// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
	//HashEntry returns pp::HashEntry:
	//	key=LiteralNameOrString "=>" value=Expression;
	public HashEntryElements getHashEntryAccess() {
		return (pHashEntry != null) ? pHashEntry : (pHashEntry = new HashEntryElements());
	}
	
	public ParserRule getHashEntryRule() {
		return getHashEntryAccess().getRule();
	}

	//// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
	//LiteralNameOrString returns pp::Expression:
	//	StringExpression | LiteralName;
	public LiteralNameOrStringElements getLiteralNameOrStringAccess() {
		return (pLiteralNameOrString != null) ? pLiteralNameOrString : (pLiteralNameOrString = new LiteralNameOrStringElements());
	}
	
	public ParserRule getLiteralNameOrStringRule() {
		return getLiteralNameOrStringAccess().getRule();
	}

	//// has converter
	//BooleanValue returns ecore::EBoolean:
	//	"true" | "false";
	public BooleanValueElements getBooleanValueAccess() {
		return (pBooleanValue != null) ? pBooleanValue : (pBooleanValue = new BooleanValueElements());
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//LiteralBoolean returns pp::LiteralBoolean:
	//	value=BooleanValue;
	public LiteralBooleanElements getLiteralBooleanAccess() {
		return (pLiteralBoolean != null) ? pLiteralBoolean : (pLiteralBoolean = new LiteralBooleanElements());
	}
	
	public ParserRule getLiteralBooleanRule() {
		return getLiteralBooleanAccess().getRule();
	}

	//LiteralDefault returns pp::LiteralDefault:
	//	{pp::LiteralDefault} "default";
	public LiteralDefaultElements getLiteralDefaultAccess() {
		return (pLiteralDefault != null) ? pLiteralDefault : (pLiteralDefault = new LiteralDefaultElements());
	}
	
	public ParserRule getLiteralDefaultRule() {
		return getLiteralDefaultAccess().getRule();
	}

	//LiteralUndef returns pp::LiteralUndef:
	//	{pp::LiteralUndef} "undef";
	public LiteralUndefElements getLiteralUndefAccess() {
		return (pLiteralUndef != null) ? pLiteralUndef : (pLiteralUndef = new LiteralUndefElements());
	}
	
	public ParserRule getLiteralUndefRule() {
		return getLiteralUndefAccess().getRule();
	}

	//StringExpression returns pp::Expression hidden(WS, SL_COMMENT, ML_COMMENT):
	//	SingleQuotedString | UnquotedString | DoubleQuotedString;
	public StringExpressionElements getStringExpressionAccess() {
		return (pStringExpression != null) ? pStringExpression : (pStringExpression = new StringExpressionElements());
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}

	//QuotedString returns pp::IQuotedString hidden(WS, SL_COMMENT, ML_COMMENT):
	//	DoubleQuotedString | SingleQuotedString;
	public QuotedStringElements getQuotedStringAccess() {
		return (pQuotedString != null) ? pQuotedString : (pQuotedString = new QuotedStringElements());
	}
	
	public ParserRule getQuotedStringRule() {
		return getQuotedStringAccess().getRule();
	}

	//SingleQuotedString returns pp::SingleQuotedString:
	//	{pp::SingleQuotedString} text=sqText;
	public SingleQuotedStringElements getSingleQuotedStringAccess() {
		return (pSingleQuotedString != null) ? pSingleQuotedString : (pSingleQuotedString = new SingleQuotedStringElements());
	}
	
	public ParserRule getSingleQuotedStringRule() {
		return getSingleQuotedStringAccess().getRule();
	}

	//// Special declarations to aid syntax coloring of a $ in a special place.	
	//DQT_DOLLAR:
	//	"$";
	public DQT_DOLLARElements getDQT_DOLLARAccess() {
		return (pDQT_DOLLAR != null) ? pDQT_DOLLAR : (pDQT_DOLLAR = new DQT_DOLLARElements());
	}
	
	public ParserRule getDQT_DOLLARRule() {
		return getDQT_DOLLARAccess().getRule();
	}

	//// Double quoted string with expression interpolation
	//// handles:
	//// - $ <non variable char or {> is a verbatim $ included in the string
	//// - $varname - evaluated and included in the string
	//// - ${ expression } - evaluated and included in the string
	////
	//DoubleQuotedString returns pp::DoubleQuotedString hidden():
	//	"\"" textExpression=TextExpression "\"";
	public DoubleQuotedStringElements getDoubleQuotedStringAccess() {
		return (pDoubleQuotedString != null) ? pDoubleQuotedString : (pDoubleQuotedString = new DoubleQuotedStringElements());
	}
	
	public ParserRule getDoubleQuotedStringRule() {
		return getDoubleQuotedStringAccess().getRule();
	}

	//// Lowest precedence TextExpression
	//TextExpression returns pp::TextExpression hidden():
	//	DollarTextExpression;
	public TextExpressionElements getTextExpressionAccess() {
		return (pTextExpression != null) ? pTextExpression : (pTextExpression = new TextExpressionElements());
	}
	
	public ParserRule getTextExpressionRule() {
		return getTextExpressionAccess().getRule();
	}

	//DollarTextExpression returns pp::TextExpression hidden():
	//	VariableTextExpression ({pp::VerbatimTE.leading=current} text=DQT_DOLLAR trailing=TextExpression?)*;
	public DollarTextExpressionElements getDollarTextExpressionAccess() {
		return (pDollarTextExpression != null) ? pDollarTextExpression : (pDollarTextExpression = new DollarTextExpressionElements());
	}
	
	public ParserRule getDollarTextExpressionRule() {
		return getDollarTextExpressionAccess().getRule();
	}

	//VariableTextExpression returns pp::TextExpression hidden():
	//	ExpressionTextExpression ({pp::VariableTE.leading=current} varName=dollarVariable trailing=TextExpression?)*;
	public VariableTextExpressionElements getVariableTextExpressionAccess() {
		return (pVariableTextExpression != null) ? pVariableTextExpression : (pVariableTextExpression = new VariableTextExpressionElements());
	}
	
	public ParserRule getVariableTextExpressionRule() {
		return getVariableTextExpressionAccess().getRule();
	}

	//ExpressionTextExpression returns pp::TextExpression hidden(): // allow comments between ${ and }
	//// validate expression is not null == warning
	//	StringPart ({pp::ExpressionTE.leading=current} "${" expression=ExpressionWithHidden "}" trailing=TextExpression?)*;
	public ExpressionTextExpressionElements getExpressionTextExpressionAccess() {
		return (pExpressionTextExpression != null) ? pExpressionTextExpression : (pExpressionTextExpression = new ExpressionTextExpressionElements());
	}
	
	public ParserRule getExpressionTextExpressionRule() {
		return getExpressionTextExpressionAccess().getRule();
	}

	//// Consumation without creation is ok, if made optional where it is assigned, it is not possible to
	//// insert WS and comments into ExpressioNTextExpression.
	//ExpressionWithHidden returns pp::Expression hidden(WS, SL_COMMENT, ML_COMMENT):
	//	{pp::ParenthesisedExpression} expr=Expression?;
	public ExpressionWithHiddenElements getExpressionWithHiddenAccess() {
		return (pExpressionWithHidden != null) ? pExpressionWithHidden : (pExpressionWithHidden = new ExpressionWithHiddenElements());
	}
	
	public ParserRule getExpressionWithHiddenRule() {
		return getExpressionWithHiddenAccess().getRule();
	}

	//StringPart returns pp::TextExpression hidden():
	//	{pp::VerbatimTE} text=doubleStringCharacters?;
	public StringPartElements getStringPartAccess() {
		return (pStringPart != null) ? pStringPart : (pStringPart = new StringPartElements());
	}
	
	public ParserRule getStringPartRule() {
		return getStringPartAccess().getRule();
	}

	//UnquotedString returns pp::Expression: // allow comments between ${ and }
	//// validate that Expression is not empty == warning
	//	{pp::UnquotedString} "${" expression=Expression? "}";
	public UnquotedStringElements getUnquotedStringAccess() {
		return (pUnquotedString != null) ? pUnquotedString : (pUnquotedString = new UnquotedStringElements());
	}
	
	public ParserRule getUnquotedStringRule() {
		return getUnquotedStringAccess().getRule();
	}

	//// Has data conversion that strips leading/trailing single quotes
	//sqText returns ecore::EString hidden():
	//	"\'" singleStringCharacters? "\'";
	public SqTextElements getSqTextAccess() {
		return (pSqText != null) ? pSqText : (pSqText = new SqTextElements());
	}
	
	public ParserRule getSqTextRule() {
		return getSqTextAccess().getRule();
	}

	//// Has validation rule that checks regex validity	
	//LiteralRegex returns pp::LiteralRegex:
	//	value=REGULAR_EXPRESSION;
	public LiteralRegexElements getLiteralRegexAccess() {
		return (pLiteralRegex != null) ? pLiteralRegex : (pLiteralRegex = new LiteralRegexElements());
	}
	
	public ParserRule getLiteralRegexRule() {
		return getLiteralRegexAccess().getRule();
	}

	//// VALIDATION: checks that the name is a NAME (and not a reference).
	//LiteralName returns pp::LiteralName:
	//	value=unionNameOrReference;
	public LiteralNameElements getLiteralNameAccess() {
		return (pLiteralName != null) ? pLiteralName : (pLiteralName = new LiteralNameElements());
	}
	
	public ParserRule getLiteralNameRule() {
		return getLiteralNameAccess().getRule();
	}

	//VariableExpression returns pp::VariableExpression:
	//	varName=dollarVariable;
	public VariableExpressionElements getVariableExpressionAccess() {
		return (pVariableExpression != null) ? pVariableExpression : (pVariableExpression = new VariableExpressionElements());
	}
	
	public ParserRule getVariableExpressionRule() {
		return getVariableExpressionAccess().getRule();
	}

	//dollarVariable hidden():
	//	"$" (variable | keyword);
	public DollarVariableElements getDollarVariableAccess() {
		return (pDollarVariable != null) ? pDollarVariable : (pDollarVariable = new DollarVariableElements());
	}
	
	public ParserRule getDollarVariableRule() {
		return getDollarVariableAccess().getRule();
	}

	//keyword:
	//	"and" | "case" | "class" | "default" | "define" | "else" | "elsif" | "in" | "inherits" | "import" | "node" | "or" |
	//	"undef" | "true" | "false" | "if";
	public KeywordElements getKeywordAccess() {
		return (pKeyword != null) ? pKeyword : (pKeyword = new KeywordElements());
	}
	
	public ParserRule getKeywordRule() {
		return getKeywordAccess().getRule();
	}

	//// a puppet grammar glitch allows '::' any number of times (\w*::)*\w+. Validation checks correctness.
	//variable hidden():
	//	WORD_CHARS;
	public VariableElements getVariableAccess() {
		return (pVariable != null) ? pVariable : (pVariable = new VariableElements());
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//// captures names and references, complicated by the fact that a keyword may be part of the name
	//// if the name contains '::' - for more info see the PPLexer
	//unionNameOrReference hidden():
	//	WORD_CHARS | "class" | "default";
	public UnionNameOrReferenceElements getUnionNameOrReferenceAccess() {
		return (pUnionNameOrReference != null) ? pUnionNameOrReference : (pUnionNameOrReference = new UnionNameOrReferenceElements());
	}
	
	public ParserRule getUnionNameOrReferenceRule() {
		return getUnionNameOrReferenceAccess().getRule();
	}

	//// special rules in lexer will deliver everything as one of these when in a string
	//doubleStringCharacters hidden():
	//	(WORD_CHARS | ANY_OTHER | WS | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+;
	public DoubleStringCharactersElements getDoubleStringCharactersAccess() {
		return (pDoubleStringCharacters != null) ? pDoubleStringCharacters : (pDoubleStringCharacters = new DoubleStringCharactersElements());
	}
	
	public ParserRule getDoubleStringCharactersRule() {
		return getDoubleStringCharactersAccess().getRule();
	}

	//// special rules in lexer will deliver everything as one of these when in a string
	//singleStringCharacters hidden():
	//	(WORD_CHARS | ANY_OTHER | WS | // terminates dq-, but not sq- string
	//	"$" | // terminates dq-, but not sq- string
	//	"${" | "\\\"" | "\\\'" | "\\$" | "\\${" | "\\\\")+;
	public SingleStringCharactersElements getSingleStringCharactersAccess() {
		return (pSingleStringCharacters != null) ? pSingleStringCharacters : (pSingleStringCharacters = new SingleStringCharactersElements());
	}
	
	public ParserRule getSingleStringCharactersRule() {
		return getSingleStringCharactersAccess().getRule();
	}

	/// ************************************************************
	// * TERMINALS 
	// * (Please no terminals above, and no rules below...)
	// * IMPORTANT: An external lexer are used - the rules below are an aproximation. The names and
	// * number of terminals may not be changed without also updating the lexer.
	// * / terminal ML_COMMENT:
	//	"/ *"->"* /" (" " | "" | "\t")* ("\r"? "\n")?;
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//// accumulate all SL comments into one token
	//terminal SL_COMMENT:
	//	"#" !("\r" | "\n")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//// Note that second space is a UNICODE NBSP
	//terminal WS:
	//	(" " | "" | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal WORD_CHARS:
	//	"::"? ("0".."9" | "a".."z" | "A".."Z" | "_" | "." | "-")+ ("::" ("0".."9" | "a".."z" | "A".."Z" | "_" | "." | "-")+)*;
	public TerminalRule getWORD_CHARSRule() {
		return (tWORD_CHARS != null) ? tWORD_CHARS : (tWORD_CHARS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WORD_CHARS"));
	} 

	//// Special rules in the lexer must prevent the RE from being recognized
	//// except after ',' 'node', '{','}, '=~', '!~'
	//terminal REGULAR_EXPRESSION:
	//	"/" RE_BODY "/" RE_FLAGS?;
	public TerminalRule getREGULAR_EXPRESSIONRule() {
		return (tREGULAR_EXPRESSION != null) ? tREGULAR_EXPRESSION : (tREGULAR_EXPRESSION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REGULAR_EXPRESSION"));
	} 

	//terminal fragment RE_BODY:
	//	RE_FIRST_CHAR RE_FOLLOW_CHAR*;
	public TerminalRule getRE_BODYRule() {
		return (tRE_BODY != null) ? tRE_BODY : (tRE_BODY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RE_BODY"));
	} 

	//// regexp can not start with:
	//// - a '*' (illegal regexp, and makes it look like a MLCOMMENT start
	//// - a '/' since that makes it empty (which is an invalid regexp)
	//// - a NL since all of the regexp must be on one line
	//terminal fragment RE_FIRST_CHAR:
	//	!("\n" | "*" | "/" | "\\") | RE_BACKSLASH_SEQUENCE;
	public TerminalRule getRE_FIRST_CHARRule() {
		return (tRE_FIRST_CHAR != null) ? tRE_FIRST_CHAR : (tRE_FIRST_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RE_FIRST_CHAR"));
	} 

	//// subsequent regexp chars include '*'
	//terminal fragment RE_FOLLOW_CHAR:
	//	RE_FIRST_CHAR | "*";
	public TerminalRule getRE_FOLLOW_CHARRule() {
		return (tRE_FOLLOW_CHAR != null) ? tRE_FOLLOW_CHAR : (tRE_FOLLOW_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RE_FOLLOW_CHAR"));
	} 

	//// Any character can be escaped except NL since all of the regexp must be on one line.
	//terminal fragment RE_BACKSLASH_SEQUENCE:
	//	"\\" !"\n";
	public TerminalRule getRE_BACKSLASH_SEQUENCERule() {
		return (tRE_BACKSLASH_SEQUENCE != null) ? tRE_BACKSLASH_SEQUENCE : (tRE_BACKSLASH_SEQUENCE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RE_BACKSLASH_SEQUENCE"));
	} 

	//// RUBY REGEX flags: i o x m u e s n (optional, or in any order, but only use each once
	//// Puppet does not support these (currently), they are recognized to enable warning that
	//// they are not supported (no other meaning can be applied to letter appearing after
	//// the end '/' in a regexp. Check for supported flags can be done in validation if they
	//// become available.
	//terminal fragment RE_FLAGS:
	//	"a".."z"+;
	public TerminalRule getRE_FLAGSRule() {
		return (tRE_FLAGS != null) ? tRE_FLAGS : (tRE_FLAGS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RE_FLAGS"));
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return (tANY_OTHER != null) ? tANY_OTHER : (tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER"));
	} 
}
